# DO NOT MODIFY
# AUTO-GENERATED CODE.

# pylint: ignore

from typing import Dict, Any

VERSION = "2.14.4"
import re
from ..fastjsonschema_replacement import JsonSchemaException


REGEX_PATTERNS = {
    "ipv4_re_pattern": re.compile(r"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\Z"),
    "ipv6_re_pattern": re.compile(r"^(?:(?:[0-9A-Fa-f]{1,4}:){6}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::(?:[0-9A-Fa-f]{1,4}:){5}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){4}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){3}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){2}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(?:(?:[0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)\Z")
}

NoneType = type(None)

def validate_discovery_map_schema_yaml(data: Dict[str, Any]) -> Dict[str, Any]:
    if not isinstance(data, (dict)):
        raise JsonSchemaException("data must be object", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Data output from the discovery-map extension point.  It describes the entire mesh.', 'type': 'object', 'required': ['version', 'namespaces'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'namespaces': {'description': 'Collection of all the namespaces and their services, colors, and routes.  This will be transformed by the entry point into the correct proxy configuration.\n', 'type': 'array', 'items': {'description': 'A single namespace and its configuration properties.', 'type': 'object', 'required': ['namespace', 'network-id', 'gateways', 'service-colors'], 'properties': {'namespace': {'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, 'network-id': {'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, 'gateways': {'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, 'service-colors': {'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}}}}}, 'definitions': {'host-port': {'oneOf': [{'description': 'An IPv4 and listening port.', 'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, 'port': {'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "An IPv6 and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['ipv6', 'port'], 'properties': {'ipv6': {'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "A DNS resolvable hostname and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['hostname', 'port'], 'properties': {'hostname': {'description': 'hostname address for this service-color instance.', 'type': 'string'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}]}}, '$id': 'file:/tmp/tmp0cldaswl/discovery-map-schema.yaml'}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_len = len(data)
        if not all(prop in data for prop in ['version', 'namespaces']):
            raise JsonSchemaException("data must contain ['version', 'namespaces'] properties", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Data output from the discovery-map extension point.  It describes the entire mesh.', 'type': 'object', 'required': ['version', 'namespaces'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'namespaces': {'description': 'Collection of all the namespaces and their services, colors, and routes.  This will be transformed by the entry point into the correct proxy configuration.\n', 'type': 'array', 'items': {'description': 'A single namespace and its configuration properties.', 'type': 'object', 'required': ['namespace', 'network-id', 'gateways', 'service-colors'], 'properties': {'namespace': {'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, 'network-id': {'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, 'gateways': {'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, 'service-colors': {'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}}}}}, 'definitions': {'host-port': {'oneOf': [{'description': 'An IPv4 and listening port.', 'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, 'port': {'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "An IPv6 and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['ipv6', 'port'], 'properties': {'ipv6': {'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "A DNS resolvable hostname and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['hostname', 'port'], 'properties': {'hostname': {'description': 'hostname address for this service-color instance.', 'type': 'string'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}]}}, '$id': 'file:/tmp/tmp0cldaswl/discovery-map-schema.yaml'}, rule='required')
        data_keys = set(data.keys())
        if "version" in data_keys:
            data_keys.remove("version")
            data__version = data["version"]
            if data__version != "v1":
                raise JsonSchemaException("data.version must be same as const definition", value=data__version, name="data.version", definition={'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, rule='const')
        if "namespaces" in data_keys:
            data_keys.remove("namespaces")
            data__namespaces = data["namespaces"]
            if not isinstance(data__namespaces, (list, tuple)):
                raise JsonSchemaException("data.namespaces must be array", value=data__namespaces, name="data.namespaces", definition={'description': 'Collection of all the namespaces and their services, colors, and routes.  This will be transformed by the entry point into the correct proxy configuration.\n', 'type': 'array', 'items': {'description': 'A single namespace and its configuration properties.', 'type': 'object', 'required': ['namespace', 'network-id', 'gateways', 'service-colors'], 'properties': {'namespace': {'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, 'network-id': {'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, 'gateways': {'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, 'service-colors': {'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}}}}, rule='type')
            data__namespaces_is_list = isinstance(data__namespaces, (list, tuple))
            if data__namespaces_is_list:
                data__namespaces_len = len(data__namespaces)
                for data__namespaces_x, data__namespaces_item in enumerate(data__namespaces):
                    if not isinstance(data__namespaces_item, (dict)):
                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}]".format(**locals())+" must be object", value=data__namespaces_item, name=""+"data.namespaces[{data__namespaces_x}]".format(**locals())+"", definition={'description': 'A single namespace and its configuration properties.', 'type': 'object', 'required': ['namespace', 'network-id', 'gateways', 'service-colors'], 'properties': {'namespace': {'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, 'network-id': {'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, 'gateways': {'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, 'service-colors': {'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}}}, rule='type')
                    data__namespaces_item_is_dict = isinstance(data__namespaces_item, dict)
                    if data__namespaces_item_is_dict:
                        data__namespaces_item_len = len(data__namespaces_item)
                        if not all(prop in data__namespaces_item for prop in ['namespace', 'network-id', 'gateways', 'service-colors']):
                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}]".format(**locals())+" must contain ['namespace', 'network-id', 'gateways', 'service-colors'] properties", value=data__namespaces_item, name=""+"data.namespaces[{data__namespaces_x}]".format(**locals())+"", definition={'description': 'A single namespace and its configuration properties.', 'type': 'object', 'required': ['namespace', 'network-id', 'gateways', 'service-colors'], 'properties': {'namespace': {'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, 'network-id': {'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, 'gateways': {'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, 'service-colors': {'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}}}, rule='required')
                        data__namespaces_item_keys = set(data__namespaces_item.keys())
                        if "namespace" in data__namespaces_item_keys:
                            data__namespaces_item_keys.remove("namespace")
                            data__namespaces_item__namespace = data__namespaces_item["namespace"]
                            if not isinstance(data__namespaces_item__namespace, (str)):
                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].namespace".format(**locals())+" must be string", value=data__namespaces_item__namespace, name=""+"data.namespaces[{data__namespaces_x}].namespace".format(**locals())+"", definition={'description': 'The namespace name.  Each must be unique.', 'type': 'string'}, rule='type')
                        if "network-id" in data__namespaces_item_keys:
                            data__namespaces_item_keys.remove("network-id")
                            data__namespaces_item__networkid = data__namespaces_item["network-id"]
                            if not isinstance(data__namespaces_item__networkid, (str)):
                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].network-id".format(**locals())+" must be string", value=data__namespaces_item__networkid, name=""+"data.namespaces[{data__namespaces_x}].network-id".format(**locals())+"", definition={'description': 'The network ID.  This can be the same as the namespace name.', 'type': 'string'}, rule='type')
                        if "gateways" in data__namespaces_item_keys:
                            data__namespaces_item_keys.remove("gateways")
                            data__namespaces_item__gateways = data__namespaces_item["gateways"]
                            if not isinstance(data__namespaces_item__gateways, (dict)):
                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].gateways".format(**locals())+" must be object", value=data__namespaces_item__gateways, name=""+"data.namespaces[{data__namespaces_x}].gateways".format(**locals())+"", definition={'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, rule='type')
                            data__namespaces_item__gateways_is_dict = isinstance(data__namespaces_item__gateways, dict)
                            if data__namespaces_item__gateways_is_dict:
                                data__namespaces_item__gateways_len = len(data__namespaces_item__gateways)
                                if not all(prop in data__namespaces_item__gateways for prop in ['instances', 'prefer-gateway']):
                                    raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].gateways".format(**locals())+" must contain ['instances', 'prefer-gateway'] properties", value=data__namespaces_item__gateways, name=""+"data.namespaces[{data__namespaces_x}].gateways".format(**locals())+"", definition={'description': 'Collection of gateway proxies that send traffic into the namespace.', 'type': 'object', 'required': ['instances', 'prefer-gateway'], 'properties': {'prefer-gateway': {'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, 'instances': {'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, rule='required')
                                data__namespaces_item__gateways_keys = set(data__namespaces_item__gateways.keys())
                                if "prefer-gateway" in data__namespaces_item__gateways_keys:
                                    data__namespaces_item__gateways_keys.remove("prefer-gateway")
                                    data__namespaces_item__gateways__prefergateway = data__namespaces_item__gateways["prefer-gateway"]
                                    if not isinstance(data__namespaces_item__gateways__prefergateway, (bool)):
                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].gateways.prefer-gateway".format(**locals())+" must be boolean", value=data__namespaces_item__gateways__prefergateway, name=""+"data.namespaces[{data__namespaces_x}].gateways.prefer-gateway".format(**locals())+"", definition={'description': 'Whether services outside this namespace should prefer to send requests to the gateway proxy (true) or use direct access (false).  Some network topologies require inter-namespace access to go through a gateway.\n', 'type': 'boolean'}, rule='type')
                                if "instances" in data__namespaces_item__gateways_keys:
                                    data__namespaces_item__gateways_keys.remove("instances")
                                    data__namespaces_item__gateways__instances = data__namespaces_item__gateways["instances"]
                                    if not isinstance(data__namespaces_item__gateways__instances, (list, tuple)):
                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].gateways.instances".format(**locals())+" must be array", value=data__namespaces_item__gateways__instances, name=""+"data.namespaces[{data__namespaces_x}].gateways.instances".format(**locals())+"", definition={'description': 'Collection of host/ports that proxy requests into the namespace.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, rule='type')
                                    data__namespaces_item__gateways__instances_is_list = isinstance(data__namespaces_item__gateways__instances, (list, tuple))
                                    if data__namespaces_item__gateways__instances_is_list:
                                        data__namespaces_item__gateways__instances_len = len(data__namespaces_item__gateways__instances)
                                        for data__namespaces_item__gateways__instances_x, data__namespaces_item__gateways__instances_item in enumerate(data__namespaces_item__gateways__instances):
                                            validate_discovery_map_schema_yaml__definitions_host_port(data__namespaces_item__gateways__instances_item)
                        if "service-colors" in data__namespaces_item_keys:
                            data__namespaces_item_keys.remove("service-colors")
                            data__namespaces_item__servicecolors = data__namespaces_item["service-colors"]
                            if not isinstance(data__namespaces_item__servicecolors, (list, tuple)):
                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors".format(**locals())+" must be array", value=data__namespaces_item__servicecolors, name=""+"data.namespaces[{data__namespaces_x}].service-colors".format(**locals())+"", definition={'description': 'List of all the service-colors.  Each running instance for a service-color must share the routing information.  If two instances have the same service-color information but different routing or weights, then the discovery map must distinguish the color between them.\n', 'type': 'array', 'items': {'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}}, rule='type')
                            data__namespaces_item__servicecolors_is_list = isinstance(data__namespaces_item__servicecolors, (list, tuple))
                            if data__namespaces_item__servicecolors_is_list:
                                data__namespaces_item__servicecolors_len = len(data__namespaces_item__servicecolors)
                                for data__namespaces_item__servicecolors_x, data__namespaces_item__servicecolors_item in enumerate(data__namespaces_item__servicecolors):
                                    if not isinstance(data__namespaces_item__servicecolors_item, (dict)):
                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}]".format(**locals())+"", definition={'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}, rule='type')
                                    data__namespaces_item__servicecolors_item_is_dict = isinstance(data__namespaces_item__servicecolors_item, dict)
                                    if data__namespaces_item__servicecolors_item_is_dict:
                                        data__namespaces_item__servicecolors_item_len = len(data__namespaces_item__servicecolors_item)
                                        if not all(prop in data__namespaces_item__servicecolors_item for prop in ['service', 'color', 'routes', 'instances', 'namespace-egress']):
                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}]".format(**locals())+" must contain ['service', 'color', 'routes', 'instances', 'namespace-egress'] properties", value=data__namespaces_item__servicecolors_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}]".format(**locals())+"", definition={'description': 'A service-color description, which has 1 or more instances associated with it.', 'type': 'object', 'required': ['service', 'color', 'routes', 'instances', 'namespace-egress'], 'properties': {'service': {'description': 'Service name.', 'type': 'string'}, 'color': {'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, 'protocol': {'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, 'routes': {'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, 'instances': {'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, 'namespace-egress': {'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}}}, rule='required')
                                        data__namespaces_item__servicecolors_item_keys = set(data__namespaces_item__servicecolors_item.keys())
                                        if "service" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("service")
                                            data__namespaces_item__servicecolors_item__service = data__namespaces_item__servicecolors_item["service"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__service, (str)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].service".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__service, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].service".format(**locals())+"", definition={'description': 'Service name.', 'type': 'string'}, rule='type')
                                        if "color" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("color")
                                            data__namespaces_item__servicecolors_item__color = data__namespaces_item__servicecolors_item["color"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__color, (str)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].color".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__color, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].color".format(**locals())+"", definition={'description': 'The service "color", which indicates different deployment characteristics of the service.\n', 'type': 'string'}, rule='type')
                                        if "protocol" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("protocol")
                                            data__namespaces_item__servicecolors_item__protocol = data__namespaces_item__servicecolors_item["protocol"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__protocol, (str)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].protocol".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__protocol, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].protocol".format(**locals())+"", definition={'description': 'The communication protocol.  If not given, this assumes HTTP 1.1.  Currently supported values are "HTTP1.1" and "HTTP2".\n', 'type': 'string'}, rule='type')
                                        if "routes" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("routes")
                                            data__namespaces_item__servicecolors_item__routes = data__namespaces_item__servicecolors_item["routes"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__routes, (list, tuple)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__routes, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes".format(**locals())+"", definition={'description': 'Collection of URL routes that the service-color serves.', 'type': 'array', 'items': {'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}}, rule='type')
                                            data__namespaces_item__servicecolors_item__routes_is_list = isinstance(data__namespaces_item__servicecolors_item__routes, (list, tuple))
                                            if data__namespaces_item__servicecolors_item__routes_is_list:
                                                data__namespaces_item__servicecolors_item__routes_len = len(data__namespaces_item__servicecolors_item__routes)
                                                for data__namespaces_item__servicecolors_item__routes_x, data__namespaces_item__servicecolors_item__routes_item in enumerate(data__namespaces_item__servicecolors_item__routes):
                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item, (dict)):
                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}]".format(**locals())+"", definition={'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}, rule='type')
                                                    data__namespaces_item__servicecolors_item__routes_item_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item, dict)
                                                    if data__namespaces_item__servicecolors_item__routes_item_is_dict:
                                                        data__namespaces_item__servicecolors_item__routes_item_len = len(data__namespaces_item__servicecolors_item__routes_item)
                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item for prop in ['path-match', 'weight', 'namespace-protection', 'default-protection']):
                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}]".format(**locals())+" must contain ['path-match', 'weight', 'namespace-protection', 'default-protection'] properties", value=data__namespaces_item__servicecolors_item__routes_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}]".format(**locals())+"", definition={'description': 'A service route.', 'type': 'object', 'required': ['path-match', 'weight', 'namespace-protection', 'default-protection'], 'properties': {'path-match': {'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, 'path-case-sensitive': {'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, 'weight': {'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, 'headers': {'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, 'query-parameters': {'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, 'default-protection': {'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, 'namespace-protection': {'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}}}, rule='required')
                                                        data__namespaces_item__servicecolors_item__routes_item_keys = set(data__namespaces_item__servicecolors_item__routes_item.keys())
                                                        if "path-match" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("path-match")
                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch = data__namespaces_item__servicecolors_item__routes_item["path-match"]
                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count = 0
                                                            if data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count < 2:
                                                                try:
                                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch, (dict)):
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_len = len(data__namespaces_item__servicecolors_item__routes_item__pathmatch)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__pathmatch for prop in ['prefix']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must contain ['prefix'] properties", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys = set(data__namespaces_item__servicecolors_item__routes_item__pathmatch.keys())
                                                                        if "prefix" in data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys.remove("prefix")
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch__prefix = data__namespaces_item__servicecolors_item__routes_item__pathmatch["prefix"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch__prefix, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.prefix".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch__prefix, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.prefix".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count < 2:
                                                                try:
                                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch, (dict)):
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_len = len(data__namespaces_item__servicecolors_item__routes_item__pathmatch)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__pathmatch for prop in ['regex']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must contain ['regex'] properties", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys = set(data__namespaces_item__servicecolors_item__routes_item__pathmatch.keys())
                                                                        if "regex" in data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys.remove("regex")
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch__regex = data__namespaces_item__servicecolors_item__routes_item__pathmatch["regex"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch__regex, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.regex".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch__regex, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.regex".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count < 2:
                                                                try:
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__pathmatch_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_len = len(data__namespaces_item__servicecolors_item__routes_item__pathmatch)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__pathmatch for prop in ['exact']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must contain ['exact'] properties", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys = set(data__namespaces_item__servicecolors_item__routes_item__pathmatch.keys())
                                                                        if "exact" in data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch_keys.remove("exact")
                                                                            data__namespaces_item__servicecolors_item__routes_item__pathmatch__exact = data__namespaces_item__servicecolors_item__routes_item__pathmatch["exact"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathmatch__exact, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.exact".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch__exact, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match.exact".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__pathmatch_one_of_count != 1:
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+" must be valid exactly by one of oneOf definition", value=data__namespaces_item__servicecolors_item__routes_item__pathmatch, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-match".format(**locals())+"", definition={'oneOf': [{'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['prefix'], 'properties': {'prefix': {'type': 'string'}}}, {'description': 'The URI path-part that handles the route.  This must be unique within the service-color.', 'type': 'object', 'required': ['regex'], 'properties': {'regex': {'type': 'string'}}}, {'description': 'The URI path-part that handels the route.', 'required': ['exact'], 'properties': {'exact': {'type': 'string'}}}]}, rule='oneOf')
                                                        if "path-case-sensitive" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("path-case-sensitive")
                                                            data__namespaces_item__servicecolors_item__routes_item__pathcasesensitive = data__namespaces_item__servicecolors_item__routes_item["path-case-sensitive"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__pathcasesensitive, (bool)):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-case-sensitive".format(**locals())+" must be boolean", value=data__namespaces_item__servicecolors_item__routes_item__pathcasesensitive, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].path-case-sensitive".format(**locals())+"", definition={'description': 'Is the path case sensitive?  Defaults to True', 'type': 'boolean'}, rule='type')
                                                        if "weight" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("weight")
                                                            data__namespaces_item__servicecolors_item__routes_item__weight = data__namespaces_item__servicecolors_item__routes_item["weight"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__weight, (int)) and not (isinstance(data__namespaces_item__servicecolors_item__routes_item__weight, float) and data__namespaces_item__servicecolors_item__routes_item__weight.is_integer()) or isinstance(data__namespaces_item__servicecolors_item__routes_item__weight, bool):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+" must be integer", value=data__namespaces_item__servicecolors_item__routes_item__weight, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+"", definition={'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, rule='type')
                                                            if isinstance(data__namespaces_item__servicecolors_item__routes_item__weight, (int, float)):
                                                                if data__namespaces_item__servicecolors_item__routes_item__weight < 1:
                                                                    raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+" must be bigger than or equal to 1", value=data__namespaces_item__servicecolors_item__routes_item__weight, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+"", definition={'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, rule='minimum')
                                                                if data__namespaces_item__servicecolors_item__routes_item__weight > 32767:
                                                                    raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+" must be smaller than or equal to 32767", value=data__namespaces_item__servicecolors_item__routes_item__weight, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].weight".format(**locals())+"", definition={'description': 'Weight to give the handling of this route.  A higher number means more traffic is directed to it.', 'type': 'integer', 'minimum': 1, 'maximum': 32767}, rule='maximum')
                                                        if "headers" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("headers")
                                                            data__namespaces_item__servicecolors_item__routes_item__headers = data__namespaces_item__servicecolors_item__routes_item["headers"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers, (list, tuple)):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__routes_item__headers, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers".format(**locals())+"", definition={'description': 'Optional list of request header fields that must also be fulfilled to pass network traffic to this route.\n', 'type': 'array', 'items': {'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}}, rule='type')
                                                            data__namespaces_item__servicecolors_item__routes_item__headers_is_list = isinstance(data__namespaces_item__servicecolors_item__routes_item__headers, (list, tuple))
                                                            if data__namespaces_item__servicecolors_item__routes_item__headers_is_list:
                                                                data__namespaces_item__servicecolors_item__routes_item__headers_len = len(data__namespaces_item__servicecolors_item__routes_item__headers)
                                                                for data__namespaces_item__servicecolors_item__routes_item__headers_x, data__namespaces_item__servicecolors_item__routes_item__headers_item in enumerate(data__namespaces_item__servicecolors_item__routes_item__headers):
                                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item, (dict)):
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item__headers_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__headers_item_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__headers_item_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__headers_item_len = len(data__namespaces_item__servicecolors_item__routes_item__headers_item)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__headers_item for prop in ['header-name', 'match-type', 'value']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}]".format(**locals())+" must contain ['header-name', 'match-type', 'value'] properties", value=data__namespaces_item__servicecolors_item__routes_item__headers_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['header-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'invert': {'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, 'case-sensitive': {'type': 'boolean'}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__headers_item_keys = set(data__namespaces_item__servicecolors_item__routes_item__headers_item.keys())
                                                                        if "header-name" in data__namespaces_item__servicecolors_item__routes_item__headers_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item_keys.remove("header-name")
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item__headername = data__namespaces_item__servicecolors_item__routes_item__headers_item["header-name"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item__headername, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].header-name".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__headers_item__headername, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].header-name".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                        if "match-type" in data__namespaces_item__servicecolors_item__routes_item__headers_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item_keys.remove("match-type")
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item__matchtype = data__namespaces_item__servicecolors_item__routes_item__headers_item["match-type"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item__matchtype, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].match-type".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__headers_item__matchtype, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].match-type".format(**locals())+"", definition={'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - header value starts with this. "suffix" - header value ends with this. "present" - header needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, rule='type')
                                                                        if "value" in data__namespaces_item__servicecolors_item__routes_item__headers_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item_keys.remove("value")
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item__value = data__namespaces_item__servicecolors_item__routes_item__headers_item["value"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item__value, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].value".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__headers_item__value, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].value".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                        if "invert" in data__namespaces_item__servicecolors_item__routes_item__headers_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item_keys.remove("invert")
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item__invert = data__namespaces_item__servicecolors_item__routes_item__headers_item["invert"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item__invert, (bool)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].invert".format(**locals())+" must be boolean", value=data__namespaces_item__servicecolors_item__routes_item__headers_item__invert, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].invert".format(**locals())+"", definition={'description': 'If true, then the match is reversed.  Defaults to false.', 'type': 'boolean'}, rule='type')
                                                                        if "case-sensitive" in data__namespaces_item__servicecolors_item__routes_item__headers_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item_keys.remove("case-sensitive")
                                                                            data__namespaces_item__servicecolors_item__routes_item__headers_item__casesensitive = data__namespaces_item__servicecolors_item__routes_item__headers_item["case-sensitive"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__headers_item__casesensitive, (bool)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].case-sensitive".format(**locals())+" must be boolean", value=data__namespaces_item__servicecolors_item__routes_item__headers_item__casesensitive, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].headers[{data__namespaces_item__servicecolors_item__routes_item__headers_x}].case-sensitive".format(**locals())+"", definition={'type': 'boolean'}, rule='type')
                                                        if "query-parameters" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("query-parameters")
                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters = data__namespaces_item__servicecolors_item__routes_item["query-parameters"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters, (list, tuple)):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters".format(**locals())+"", definition={'description': 'query parameter filters', 'type': 'array', 'items': {'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}}, rule='type')
                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_is_list = isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters, (list, tuple))
                                                            if data__namespaces_item__servicecolors_item__routes_item__queryparameters_is_list:
                                                                data__namespaces_item__servicecolors_item__routes_item__queryparameters_len = len(data__namespaces_item__servicecolors_item__routes_item__queryparameters)
                                                                for data__namespaces_item__servicecolors_item__routes_item__queryparameters_x, data__namespaces_item__servicecolors_item__routes_item__queryparameters_item in enumerate(data__namespaces_item__servicecolors_item__routes_item__queryparameters):
                                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item, (dict)):
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_len = len(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__queryparameters_item for prop in ['parameter-name', 'match-type', 'value']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}]".format(**locals())+" must contain ['parameter-name', 'match-type', 'value'] properties", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['parameter-name', 'match-type', 'value'], 'properties': {'header-name': {'type': 'string'}, 'match-type': {'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, 'value': {'type': 'string'}, 'case-sensitive': {'type': 'boolean'}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys = set(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item.keys())
                                                                        if "header-name" in data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys.remove("header-name")
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__headername = data__namespaces_item__servicecolors_item__routes_item__queryparameters_item["header-name"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__headername, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].header-name".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__headername, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].header-name".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                        if "match-type" in data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys.remove("match-type")
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__matchtype = data__namespaces_item__servicecolors_item__routes_item__queryparameters_item["match-type"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__matchtype, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].match-type".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__matchtype, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].match-type".format(**locals())+"", definition={'description': 'Describes how the value is interpreted. "exact" - exact matching of the value. "regex" - regular expression. "prefix" - parameter value starts with this. "suffix" - parameter value ends with this. "present" - parameter needs to just be present.  The "value" is ignored.\n', 'type': 'string'}, rule='type')
                                                                        if "value" in data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys.remove("value")
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__value = data__namespaces_item__servicecolors_item__routes_item__queryparameters_item["value"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__value, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].value".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__value, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].value".format(**locals())+"", definition={'type': 'string'}, rule='type')
                                                                        if "case-sensitive" in data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item_keys.remove("case-sensitive")
                                                                            data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__casesensitive = data__namespaces_item__servicecolors_item__routes_item__queryparameters_item["case-sensitive"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__casesensitive, (bool)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].case-sensitive".format(**locals())+" must be boolean", value=data__namespaces_item__servicecolors_item__routes_item__queryparameters_item__casesensitive, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].query-parameters[{data__namespaces_item__servicecolors_item__routes_item__queryparameters_x}].case-sensitive".format(**locals())+"", definition={'type': 'boolean'}, rule='type')
                                                        if "default-protection" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("default-protection")
                                                            data__namespaces_item__servicecolors_item__routes_item__defaultprotection = data__namespaces_item__servicecolors_item__routes_item["default-protection"]
                                                            data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count = 0
                                                            if data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count < 2:
                                                                try:
                                                                    if data__namespaces_item__servicecolors_item__routes_item__defaultprotection != "public":
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__defaultprotection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+"", definition={'const': 'public', 'description': 'Allow access only to public routes.'}, rule='const')
                                                                    data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count < 2:
                                                                try:
                                                                    if data__namespaces_item__servicecolors_item__routes_item__defaultprotection != "private":
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__defaultprotection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+"", definition={'const': 'private', 'description': 'Allow access to all public and private routes.'}, rule='const')
                                                                    data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count < 2:
                                                                try:
                                                                    if data__namespaces_item__servicecolors_item__routes_item__defaultprotection != "none":
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__defaultprotection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+"", definition={'const': 'none', 'description': 'Allow no access to any routes.'}, rule='const')
                                                                    data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count += 1
                                                                except JsonSchemaException: pass
                                                            if data__namespaces_item__servicecolors_item__routes_item__defaultprotection_one_of_count != 1:
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+" must be valid exactly by one of oneOf definition", value=data__namespaces_item__servicecolors_item__routes_item__defaultprotection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].default-protection".format(**locals())+"", definition={'description': 'Default protection level for any namespace not specified. Also, gateways only look at this protection level to determine whether a route is generally public or not.\n', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, rule='oneOf')
                                                        if "namespace-protection" in data__namespaces_item__servicecolors_item__routes_item_keys:
                                                            data__namespaces_item__servicecolors_item__routes_item_keys.remove("namespace-protection")
                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection = data__namespaces_item__servicecolors_item__routes_item["namespace-protection"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection, (list, tuple)):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection".format(**locals())+"", definition={'description': "Collection of each namespace's allowed access. If a namespace exists that is not given here, then the default-protection is used for that namespace.\n", 'type': 'array', 'items': {'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}}, rule='type')
                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_is_list = isinstance(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection, (list, tuple))
                                                            if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_is_list:
                                                                data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_len = len(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection)
                                                                for data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x, data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item in enumerate(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection):
                                                                    if not isinstance(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item, (dict)):
                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}]".format(**locals())+"", definition={'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}, rule='type')
                                                                    data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_is_dict = isinstance(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item, dict)
                                                                    if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_is_dict:
                                                                        data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_len = len(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item)
                                                                        if not all(prop in data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item for prop in ['namespace', 'protection']):
                                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}]".format(**locals())+" must contain ['namespace', 'protection'] properties", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}]".format(**locals())+"", definition={'description': 'A namespace protection level.', 'type': 'object', 'required': ['namespace', 'protection'], 'properties': {'namespace': {'description': 'The namespace protection to grant access.', 'type': 'string'}, 'protection': {'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}}}, rule='required')
                                                                        data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_keys = set(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item.keys())
                                                                        if "namespace" in data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_keys.remove("namespace")
                                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__namespace = data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item["namespace"]
                                                                            if not isinstance(data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__namespace, (str)):
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].namespace".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__namespace, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].namespace".format(**locals())+"", definition={'description': 'The namespace protection to grant access.', 'type': 'string'}, rule='type')
                                                                        if "protection" in data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_keys:
                                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item_keys.remove("protection")
                                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection = data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item["protection"]
                                                                            data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count = 0
                                                                            if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count < 2:
                                                                                try:
                                                                                    if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection != "public":
                                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+"", definition={'const': 'public', 'description': 'Allow access only to public routes.'}, rule='const')
                                                                                    data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count += 1
                                                                                except JsonSchemaException: pass
                                                                            if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count < 2:
                                                                                try:
                                                                                    if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection != "private":
                                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+"", definition={'const': 'private', 'description': 'Allow access to all public and private routes.'}, rule='const')
                                                                                    data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count += 1
                                                                                except JsonSchemaException: pass
                                                                            if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count < 2:
                                                                                try:
                                                                                    if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection != "none":
                                                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+" must be same as const definition", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+"", definition={'const': 'none', 'description': 'Allow no access to any routes.'}, rule='const')
                                                                                    data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count += 1
                                                                                except JsonSchemaException: pass
                                                                            if data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection_one_of_count != 1:
                                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+" must be valid exactly by one of oneOf definition", value=data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_item__protection, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].routes[{data__namespaces_item__servicecolors_item__routes_x}].namespace-protection[{data__namespaces_item__servicecolors_item__routes_item__namespaceprotection_x}].protection".format(**locals())+"", definition={'description': 'Protection level for the namespace.', 'oneOf': [{'const': 'public', 'description': 'Allow access only to public routes.'}, {'const': 'private', 'description': 'Allow access to all public and private routes.'}, {'const': 'none', 'description': 'Allow no access to any routes.'}]}, rule='oneOf')
                                        if "instances" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("instances")
                                            data__namespaces_item__servicecolors_item__instances = data__namespaces_item__servicecolors_item["instances"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__instances, (list, tuple)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].instances".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__instances, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].instances".format(**locals())+"", definition={'description': 'Collection of IP and listening ports for handlers of this service-color routes.', 'type': 'array', 'items': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}, rule='type')
                                            data__namespaces_item__servicecolors_item__instances_is_list = isinstance(data__namespaces_item__servicecolors_item__instances, (list, tuple))
                                            if data__namespaces_item__servicecolors_item__instances_is_list:
                                                data__namespaces_item__servicecolors_item__instances_len = len(data__namespaces_item__servicecolors_item__instances)
                                                for data__namespaces_item__servicecolors_item__instances_x, data__namespaces_item__servicecolors_item__instances_item in enumerate(data__namespaces_item__servicecolors_item__instances):
                                                    validate_discovery_map_schema_yaml__definitions_host_port(data__namespaces_item__servicecolors_item__instances_item)
                                        if "namespace-egress" in data__namespaces_item__servicecolors_item_keys:
                                            data__namespaces_item__servicecolors_item_keys.remove("namespace-egress")
                                            data__namespaces_item__servicecolors_item__namespaceegress = data__namespaces_item__servicecolors_item["namespace-egress"]
                                            if not isinstance(data__namespaces_item__servicecolors_item__namespaceegress, (list, tuple)):
                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress".format(**locals())+" must be array", value=data__namespaces_item__servicecolors_item__namespaceegress, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress".format(**locals())+"", definition={'description': 'The host and port that this service-color sends requests to access each namespace.', 'type': 'array', 'items': {'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}}, rule='type')
                                            data__namespaces_item__servicecolors_item__namespaceegress_is_list = isinstance(data__namespaces_item__servicecolors_item__namespaceegress, (list, tuple))
                                            if data__namespaces_item__servicecolors_item__namespaceegress_is_list:
                                                data__namespaces_item__servicecolors_item__namespaceegress_len = len(data__namespaces_item__servicecolors_item__namespaceegress)
                                                for data__namespaces_item__servicecolors_item__namespaceegress_x, data__namespaces_item__servicecolors_item__namespaceegress_item in enumerate(data__namespaces_item__servicecolors_item__namespaceegress):
                                                    if not isinstance(data__namespaces_item__servicecolors_item__namespaceegress_item, (dict)):
                                                        raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}]".format(**locals())+" must be object", value=data__namespaces_item__servicecolors_item__namespaceegress_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}]".format(**locals())+"", definition={'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}, rule='type')
                                                    data__namespaces_item__servicecolors_item__namespaceegress_item_is_dict = isinstance(data__namespaces_item__servicecolors_item__namespaceegress_item, dict)
                                                    if data__namespaces_item__servicecolors_item__namespaceegress_item_is_dict:
                                                        data__namespaces_item__servicecolors_item__namespaceegress_item_len = len(data__namespaces_item__servicecolors_item__namespaceegress_item)
                                                        if not all(prop in data__namespaces_item__servicecolors_item__namespaceegress_item for prop in ['namespace', 'interface']):
                                                            raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}]".format(**locals())+" must contain ['namespace', 'interface'] properties", value=data__namespaces_item__servicecolors_item__namespaceegress_item, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}]".format(**locals())+"", definition={'description': "A host and port that describes the URI this service-color sends requests to for access to a namespace's routes.  That namespace's protections will be applied.  This should be an interface on the local, sidecar proxy.\n", 'type': 'object', 'required': ['namespace', 'interface'], 'properties': {'namespace': {'description': 'The namespace that this interface servces.', 'type': 'string'}, 'interface': {'$ref': 'file:///tmp/tmp0cldaswl/discovery-map-schema.yaml#/definitions/host-port'}}}, rule='required')
                                                        data__namespaces_item__servicecolors_item__namespaceegress_item_keys = set(data__namespaces_item__servicecolors_item__namespaceegress_item.keys())
                                                        if "namespace" in data__namespaces_item__servicecolors_item__namespaceegress_item_keys:
                                                            data__namespaces_item__servicecolors_item__namespaceegress_item_keys.remove("namespace")
                                                            data__namespaces_item__servicecolors_item__namespaceegress_item__namespace = data__namespaces_item__servicecolors_item__namespaceegress_item["namespace"]
                                                            if not isinstance(data__namespaces_item__servicecolors_item__namespaceegress_item__namespace, (str)):
                                                                raise JsonSchemaException(""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}].namespace".format(**locals())+" must be string", value=data__namespaces_item__servicecolors_item__namespaceegress_item__namespace, name=""+"data.namespaces[{data__namespaces_x}].service-colors[{data__namespaces_item__servicecolors_x}].namespace-egress[{data__namespaces_item__servicecolors_item__namespaceegress_x}].namespace".format(**locals())+"", definition={'description': 'The namespace that this interface servces.', 'type': 'string'}, rule='type')
                                                        if "interface" in data__namespaces_item__servicecolors_item__namespaceegress_item_keys:
                                                            data__namespaces_item__servicecolors_item__namespaceegress_item_keys.remove("interface")
                                                            data__namespaces_item__servicecolors_item__namespaceegress_item__interface = data__namespaces_item__servicecolors_item__namespaceegress_item["interface"]
                                                            validate_discovery_map_schema_yaml__definitions_host_port(data__namespaces_item__servicecolors_item__namespaceegress_item__interface)
    return data

def validate_discovery_map_schema_yaml__definitions_host_port(data: Dict[str, Any]) -> Dict[str, Any]:
    data_one_of_count = 0
    if data_one_of_count < 2:
        try:
            if not isinstance(data, (dict)):
                raise JsonSchemaException("data must be object", value=data, name="data", definition={'description': 'An IPv4 and listening port.', 'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, 'port': {'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='type')
            data_is_dict = isinstance(data, dict)
            if data_is_dict:
                data_len = len(data)
                if not all(prop in data for prop in ['ipv4', 'port']):
                    raise JsonSchemaException("data must contain ['ipv4', 'port'] properties", value=data, name="data", definition={'description': 'An IPv4 and listening port.', 'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, 'port': {'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='required')
                data_keys = set(data.keys())
                if "ipv4" in data_keys:
                    data_keys.remove("ipv4")
                    data__ipv4 = data["ipv4"]
                    if not isinstance(data__ipv4, (str)):
                        raise JsonSchemaException("data.ipv4 must be string", value=data__ipv4, name="data.ipv4", definition={'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, rule='type')
                    if isinstance(data__ipv4, str):
                        if not REGEX_PATTERNS["ipv4_re_pattern"].match(data__ipv4):
                            raise JsonSchemaException("data.ipv4 must be ipv4", value=data__ipv4, name="data.ipv4", definition={'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, rule='format')
                if "port" in data_keys:
                    data_keys.remove("port")
                    data__port = data["port"]
                    if not isinstance(data__port, (int)) and not (isinstance(data__port, float) and data__port.is_integer()) or isinstance(data__port, bool):
                        raise JsonSchemaException("data.port must be integer", value=data__port, name="data.port", definition={'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='type')
                    if isinstance(data__port, (int, float)):
                        if data__port < 1:
                            raise JsonSchemaException("data.port must be bigger than or equal to 1", value=data__port, name="data.port", definition={'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='minimum')
                        if data__port > 65535:
                            raise JsonSchemaException("data.port must be smaller than or equal to 65535", value=data__port, name="data.port", definition={'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='maximum')
            data_one_of_count += 1
        except JsonSchemaException: pass
    if data_one_of_count < 2:
        try:
            if not isinstance(data, (dict)):
                raise JsonSchemaException("data must be object", value=data, name="data", definition={'description': "An IPv6 and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['ipv6', 'port'], 'properties': {'ipv6': {'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='type')
            data_is_dict = isinstance(data, dict)
            if data_is_dict:
                data_len = len(data)
                if not all(prop in data for prop in ['ipv6', 'port']):
                    raise JsonSchemaException("data must contain ['ipv6', 'port'] properties", value=data, name="data", definition={'description': "An IPv6 and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['ipv6', 'port'], 'properties': {'ipv6': {'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='required')
                data_keys = set(data.keys())
                if "ipv6" in data_keys:
                    data_keys.remove("ipv6")
                    data__ipv6 = data["ipv6"]
                    if not isinstance(data__ipv6, (str)):
                        raise JsonSchemaException("data.ipv6 must be string", value=data__ipv6, name="data.ipv6", definition={'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, rule='type')
                    if isinstance(data__ipv6, str):
                        if not REGEX_PATTERNS["ipv6_re_pattern"].match(data__ipv6):
                            raise JsonSchemaException("data.ipv6 must be ipv6", value=data__ipv6, name="data.ipv6", definition={'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, rule='format')
                if "port" in data_keys:
                    data_keys.remove("port")
                    data__port = data["port"]
                    if not isinstance(data__port, (int)) and not (isinstance(data__port, float) and data__port.is_integer()) or isinstance(data__port, bool):
                        raise JsonSchemaException("data.port must be integer", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='type')
                    if isinstance(data__port, (int, float)):
                        if data__port < 1:
                            raise JsonSchemaException("data.port must be bigger than or equal to 1", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='minimum')
                        if data__port > 65535:
                            raise JsonSchemaException("data.port must be smaller than or equal to 65535", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='maximum')
            data_one_of_count += 1
        except JsonSchemaException: pass
    if data_one_of_count < 2:
        try:
            if not isinstance(data, (dict)):
                raise JsonSchemaException("data must be object", value=data, name="data", definition={'description': "A DNS resolvable hostname and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['hostname', 'port'], 'properties': {'hostname': {'description': 'hostname address for this service-color instance.', 'type': 'string'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='type')
            data_is_dict = isinstance(data, dict)
            if data_is_dict:
                data_len = len(data)
                if not all(prop in data for prop in ['hostname', 'port']):
                    raise JsonSchemaException("data must contain ['hostname', 'port'] properties", value=data, name="data", definition={'description': "A DNS resolvable hostname and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['hostname', 'port'], 'properties': {'hostname': {'description': 'hostname address for this service-color instance.', 'type': 'string'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, rule='required')
                data_keys = set(data.keys())
                if "hostname" in data_keys:
                    data_keys.remove("hostname")
                    data__hostname = data["hostname"]
                    if not isinstance(data__hostname, (str)):
                        raise JsonSchemaException("data.hostname must be string", value=data__hostname, name="data.hostname", definition={'description': 'hostname address for this service-color instance.', 'type': 'string'}, rule='type')
                if "port" in data_keys:
                    data_keys.remove("port")
                    data__port = data["port"]
                    if not isinstance(data__port, (int)) and not (isinstance(data__port, float) and data__port.is_integer()) or isinstance(data__port, bool):
                        raise JsonSchemaException("data.port must be integer", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='type')
                    if isinstance(data__port, (int, float)):
                        if data__port < 1:
                            raise JsonSchemaException("data.port must be bigger than or equal to 1", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='minimum')
                        if data__port > 65535:
                            raise JsonSchemaException("data.port must be smaller than or equal to 65535", value=data__port, name="data.port", definition={'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}, rule='maximum')
            data_one_of_count += 1
        except JsonSchemaException: pass
    if data_one_of_count != 1:
        raise JsonSchemaException("data must be valid exactly by one of oneOf definition", value=data, name="data", definition={'oneOf': [{'description': 'An IPv4 and listening port.', 'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address.', 'type': 'string', 'format': 'ipv4'}, 'port': {'description': 'Listening port.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "An IPv6 and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['ipv6', 'port'], 'properties': {'ipv6': {'description': 'IPv6 address for this service-color instance.', 'type': 'string', 'format': 'ipv6'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}, {'description': "A DNS resolvable hostname and listening port for a handler of this service-color's routes.", 'type': 'object', 'required': ['hostname', 'port'], 'properties': {'hostname': {'description': 'hostname address for this service-color instance.', 'type': 'string'}, 'port': {'description': 'Listening port that services the routes.', 'type': 'integer', 'minimum': 1, 'maximum': 65535}}}]}, rule='oneOf')
    return data