# DO NOT MODIFY
# AUTO-GENERATED CODE.

# pylint: ignore

from typing import Dict, Any

VERSION = "2.14.4"
from ..fastjsonschema_replacement import JsonSchemaException


NoneType = type(None)

def validate_service_mesh_map_schema_yaml(data: Dict[str, Any]) -> Dict[str, Any]:
    if not isinstance(data, (dict)):
        raise JsonSchemaException("data must be object", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Consolidation of all the service data parts for an entire mesh.', 'type': 'object', 'required': ['version', 'gateways', 'services'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'gateways': {'description': 'List of all the gateway configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}, 'services': {'description': 'List of all service ID specific configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'service', 'color', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, 'service': {'description': 'Name of the service classification.', 'type': 'string'}, 'color': {'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, 'service-id': {'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, 'namespace-id': {'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}}, '$defs': {'service-data-schema': {'$ref': 'file:///tmp/tmpkhgdcc97/service-data-schema.yaml'}}, '$id': 'file:/tmp/tmpkhgdcc97/service-mesh-map-schema.yaml'}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_len = len(data)
        if not all(prop in data for prop in ['version', 'gateways', 'services']):
            raise JsonSchemaException("data must contain ['version', 'gateways', 'services'] properties", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Consolidation of all the service data parts for an entire mesh.', 'type': 'object', 'required': ['version', 'gateways', 'services'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'gateways': {'description': 'List of all the gateway configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}, 'services': {'description': 'List of all service ID specific configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'service', 'color', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, 'service': {'description': 'Name of the service classification.', 'type': 'string'}, 'color': {'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, 'service-id': {'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, 'namespace-id': {'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}}, '$defs': {'service-data-schema': {'$ref': 'file:///tmp/tmpkhgdcc97/service-data-schema.yaml'}}, '$id': 'file:/tmp/tmpkhgdcc97/service-mesh-map-schema.yaml'}, rule='required')
        data_keys = set(data.keys())
        if "version" in data_keys:
            data_keys.remove("version")
            data__version = data["version"]
            if data__version != "v1":
                raise JsonSchemaException("data.version must be same as const definition", value=data__version, name="data.version", definition={'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, rule='const')
        if "gateways" in data_keys:
            data_keys.remove("gateways")
            data__gateways = data["gateways"]
            if not isinstance(data__gateways, (list, tuple)):
                raise JsonSchemaException("data.gateways must be array", value=data__gateways, name="data.gateways", definition={'description': 'List of all the gateway configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}, rule='type')
            data__gateways_is_list = isinstance(data__gateways, (list, tuple))
            if data__gateways_is_list:
                data__gateways_len = len(data__gateways)
                for data__gateways_x, data__gateways_item in enumerate(data__gateways):
                    if not isinstance(data__gateways_item, (dict)):
                        raise JsonSchemaException(""+"data.gateways[{data__gateways_x}]".format(**locals())+" must be object", value=data__gateways_item, name=""+"data.gateways[{data__gateways_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['namespace', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}, rule='type')
                    data__gateways_item_is_dict = isinstance(data__gateways_item, dict)
                    if data__gateways_item_is_dict:
                        data__gateways_item_len = len(data__gateways_item)
                        if not all(prop in data__gateways_item for prop in ['namespace', 'configuration']):
                            raise JsonSchemaException(""+"data.gateways[{data__gateways_x}]".format(**locals())+" must contain ['namespace', 'configuration'] properties", value=data__gateways_item, name=""+"data.gateways[{data__gateways_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['namespace', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}, rule='required')
                        data__gateways_item_keys = set(data__gateways_item.keys())
                        if "namespace" in data__gateways_item_keys:
                            data__gateways_item_keys.remove("namespace")
                            data__gateways_item__namespace = data__gateways_item["namespace"]
                            if not isinstance(data__gateways_item__namespace, (str)):
                                raise JsonSchemaException(""+"data.gateways[{data__gateways_x}].namespace".format(**locals())+" must be string", value=data__gateways_item__namespace, name=""+"data.gateways[{data__gateways_x}].namespace".format(**locals())+"", definition={'description': 'Namespace sub-mesh that the gateway governs entrance to.', 'type': 'string'}, rule='type')
                        if "configuration" in data__gateways_item_keys:
                            data__gateways_item_keys.remove("configuration")
                            data__gateways_item__configuration = data__gateways_item["configuration"]
                            validate_service_mesh_map_schema_yaml___defs_service_data_schema(data__gateways_item__configuration)
        if "services" in data_keys:
            data_keys.remove("services")
            data__services = data["services"]
            if not isinstance(data__services, (list, tuple)):
                raise JsonSchemaException("data.services must be array", value=data__services, name="data.services", definition={'description': 'List of all service ID specific configurations.', 'type': 'array', 'items': {'type': 'object', 'required': ['namespace', 'service', 'color', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, 'service': {'description': 'Name of the service classification.', 'type': 'string'}, 'color': {'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, 'service-id': {'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, 'namespace-id': {'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}}, rule='type')
            data__services_is_list = isinstance(data__services, (list, tuple))
            if data__services_is_list:
                data__services_len = len(data__services)
                for data__services_x, data__services_item in enumerate(data__services):
                    if not isinstance(data__services_item, (dict)):
                        raise JsonSchemaException(""+"data.services[{data__services_x}]".format(**locals())+" must be object", value=data__services_item, name=""+"data.services[{data__services_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['namespace', 'service', 'color', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, 'service': {'description': 'Name of the service classification.', 'type': 'string'}, 'color': {'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, 'service-id': {'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, 'namespace-id': {'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}, rule='type')
                    data__services_item_is_dict = isinstance(data__services_item, dict)
                    if data__services_item_is_dict:
                        data__services_item_len = len(data__services_item)
                        if not all(prop in data__services_item for prop in ['namespace', 'service', 'color', 'configuration']):
                            raise JsonSchemaException(""+"data.services[{data__services_x}]".format(**locals())+" must contain ['namespace', 'service', 'color', 'configuration'] properties", value=data__services_item, name=""+"data.services[{data__services_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['namespace', 'service', 'color', 'configuration'], 'properties': {'namespace': {'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, 'service': {'description': 'Name of the service classification.', 'type': 'string'}, 'color': {'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, 'service-id': {'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, 'namespace-id': {'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, 'configuration': {'$ref': 'file:///tmp/tmpkhgdcc97/service-mesh-map-schema.yaml#/$defs/service-data-schema'}}}, rule='required')
                        data__services_item_keys = set(data__services_item.keys())
                        if "namespace" in data__services_item_keys:
                            data__services_item_keys.remove("namespace")
                            data__services_item__namespace = data__services_item["namespace"]
                            if not isinstance(data__services_item__namespace, (str)):
                                raise JsonSchemaException(""+"data.services[{data__services_x}].namespace".format(**locals())+" must be string", value=data__services_item__namespace, name=""+"data.services[{data__services_x}].namespace".format(**locals())+"", definition={'description': 'Namespace sub-mesh to which this service belongs.', 'type': 'string'}, rule='type')
                        if "service" in data__services_item_keys:
                            data__services_item_keys.remove("service")
                            data__services_item__service = data__services_item["service"]
                            if not isinstance(data__services_item__service, (str)):
                                raise JsonSchemaException(""+"data.services[{data__services_x}].service".format(**locals())+" must be string", value=data__services_item__service, name=""+"data.services[{data__services_x}].service".format(**locals())+"", definition={'description': 'Name of the service classification.', 'type': 'string'}, rule='type')
                        if "color" in data__services_item_keys:
                            data__services_item_keys.remove("color")
                            data__services_item__color = data__services_item["color"]
                            if not isinstance(data__services_item__color, (str)):
                                raise JsonSchemaException(""+"data.services[{data__services_x}].color".format(**locals())+" must be string", value=data__services_item__color, name=""+"data.services[{data__services_x}].color".format(**locals())+"", definition={'description': 'Service color, for alternate route path weights within the same service.  This allows for techniques like canary testing.', 'type': 'string'}, rule='type')
                        if "service-id" in data__services_item_keys:
                            data__services_item_keys.remove("service-id")
                            data__services_item__serviceid = data__services_item["service-id"]
                            if not isinstance(data__services_item__serviceid, (str)):
                                raise JsonSchemaException(""+"data.services[{data__services_x}].service-id".format(**locals())+" must be string", value=data__services_item__serviceid, name=""+"data.services[{data__services_x}].service-id".format(**locals())+"", definition={'description': 'Optional opaque service ID the configuration was explicitly constructed for.', 'type': 'string'}, rule='type')
                        if "namespace-id" in data__services_item_keys:
                            data__services_item_keys.remove("namespace-id")
                            data__services_item__namespaceid = data__services_item["namespace-id"]
                            if not isinstance(data__services_item__namespaceid, (str)):
                                raise JsonSchemaException(""+"data.services[{data__services_x}].namespace-id".format(**locals())+" must be string", value=data__services_item__namespaceid, name=""+"data.services[{data__services_x}].namespace-id".format(**locals())+"", definition={'description': 'Optional opaque namespace ID the configuration was explicitly constructed for.', 'type': 'string'}, rule='type')
                        if "configuration" in data__services_item_keys:
                            data__services_item_keys.remove("configuration")
                            data__services_item__configuration = data__services_item["configuration"]
                            validate_service_mesh_map_schema_yaml___defs_service_data_schema(data__services_item__configuration)
    return data

def validate_service_mesh_map_schema_yaml___defs_service_data_schema(data: Dict[str, Any]) -> Dict[str, Any]:
    validate_service_data_schema_yaml(data)
    return data

def validate_service_data_schema_yaml(data: Dict[str, Any]) -> Dict[str, Any]:
    if not isinstance(data, (dict)):
        raise JsonSchemaException("data must be object", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Input data for the mustache file generation.  The data is constructed in the script, but this file keeps the template reference easy.', 'type': 'object', 'required': ['version', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'network_name': {'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, 'service_member': {'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, 'has_admin_port': {'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, 'admin_port': {'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, 'listeners': {'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, 'has_clusters': {'description': 'are there 1 or more clusters?', 'type': 'boolean'}, 'clusters': {'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}}, '$id': 'file:/tmp/tmpkhgdcc97/service-data-schema.yaml'}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_len = len(data)
        if not all(prop in data for prop in ['version', 'has_admin_port', 'listeners', 'has_clusters', 'clusters']):
            raise JsonSchemaException("data must contain ['version', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'] properties", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Input data for the mustache file generation.  The data is constructed in the script, but this file keeps the template reference easy.', 'type': 'object', 'required': ['version', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'], 'properties': {'version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'network_name': {'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, 'service_member': {'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, 'has_admin_port': {'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, 'admin_port': {'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, 'listeners': {'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, 'has_clusters': {'description': 'are there 1 or more clusters?', 'type': 'boolean'}, 'clusters': {'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}}, '$id': 'file:/tmp/tmpkhgdcc97/service-data-schema.yaml'}, rule='required')
        data_keys = set(data.keys())
        if "version" in data_keys:
            data_keys.remove("version")
            data__version = data["version"]
            if data__version != "v1":
                raise JsonSchemaException("data.version must be same as const definition", value=data__version, name="data.version", definition={'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, rule='const')
        if "network_name" in data_keys:
            data_keys.remove("network_name")
            data__networkname = data["network_name"]
            if not isinstance(data__networkname, (str)):
                raise JsonSchemaException("data.network_name must be string", value=data__networkname, name="data.network_name", definition={'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, rule='type')
        if "service_member" in data_keys:
            data_keys.remove("service_member")
            data__servicemember = data["service_member"]
            if not isinstance(data__servicemember, (str)):
                raise JsonSchemaException("data.service_member must be string", value=data__servicemember, name="data.service_member", definition={'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, rule='type')
        if "has_admin_port" in data_keys:
            data_keys.remove("has_admin_port")
            data__hasadminport = data["has_admin_port"]
            if not isinstance(data__hasadminport, (bool)):
                raise JsonSchemaException("data.has_admin_port must be boolean", value=data__hasadminport, name="data.has_admin_port", definition={'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, rule='type')
        if "admin_port" in data_keys:
            data_keys.remove("admin_port")
            data__adminport = data["admin_port"]
            if not isinstance(data__adminport, (int, NoneType)) and not (isinstance(data__adminport, float) and data__adminport.is_integer()) or isinstance(data__adminport, bool):
                raise JsonSchemaException("data.admin_port must be integer or null", value=data__adminport, name="data.admin_port", definition={'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, rule='type')
        if "listeners" in data_keys:
            data_keys.remove("listeners")
            data__listeners = data["listeners"]
            if not isinstance(data__listeners, (list, tuple)):
                raise JsonSchemaException("data.listeners must be array", value=data__listeners, name="data.listeners", definition={'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, rule='type')
            data__listeners_is_list = isinstance(data__listeners, (list, tuple))
            if data__listeners_is_list:
                data__listeners_len = len(data__listeners)
                for data__listeners_x, data__listeners_item in enumerate(data__listeners):
                    if not isinstance(data__listeners_item, (dict)):
                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}]".format(**locals())+" must be object", value=data__listeners_item, name=""+"data.listeners[{data__listeners_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}, rule='type')
                    data__listeners_item_is_dict = isinstance(data__listeners_item, dict)
                    if data__listeners_item_is_dict:
                        data__listeners_item_len = len(data__listeners_item)
                        if not all(prop in data__listeners_item for prop in ['has_mesh_port', 'routes']):
                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}]".format(**locals())+" must contain ['has_mesh_port', 'routes'] properties", value=data__listeners_item, name=""+"data.listeners[{data__listeners_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}, rule='required')
                        data__listeners_item_keys = set(data__listeners_item.keys())
                        if "has_mesh_port" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("has_mesh_port")
                            data__listeners_item__hasmeshport = data__listeners_item["has_mesh_port"]
                            if not isinstance(data__listeners_item__hasmeshport, (bool)):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].has_mesh_port".format(**locals())+" must be boolean", value=data__listeners_item__hasmeshport, name=""+"data.listeners[{data__listeners_x}].has_mesh_port".format(**locals())+"", definition={'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, rule='type')
                        if "mesh_port" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("mesh_port")
                            data__listeners_item__meshport = data__listeners_item["mesh_port"]
                            if not isinstance(data__listeners_item__meshport, (int, NoneType)) and not (isinstance(data__listeners_item__meshport, float) and data__listeners_item__meshport.is_integer()) or isinstance(data__listeners_item__meshport, bool):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].mesh_port".format(**locals())+" must be integer or null", value=data__listeners_item__meshport, name=""+"data.listeners[{data__listeners_x}].mesh_port".format(**locals())+"", definition={'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, rule='type')
                        if "routes" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("routes")
                            data__listeners_item__routes = data__listeners_item["routes"]
                            if not isinstance(data__listeners_item__routes, (list, tuple)):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes".format(**locals())+" must be array", value=data__listeners_item__routes, name=""+"data.listeners[{data__listeners_x}].routes".format(**locals())+"", definition={'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}, rule='type')
                            data__listeners_item__routes_is_list = isinstance(data__listeners_item__routes, (list, tuple))
                            if data__listeners_item__routes_is_list:
                                data__listeners_item__routes_len = len(data__listeners_item__routes)
                                for data__listeners_item__routes_x, data__listeners_item__routes_item in enumerate(data__listeners_item__routes):
                                    if not isinstance(data__listeners_item__routes_item, (dict)):
                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}, rule='type')
                                    data__listeners_item__routes_item_is_dict = isinstance(data__listeners_item__routes_item, dict)
                                    if data__listeners_item__routes_item_is_dict:
                                        data__listeners_item__routes_item_len = len(data__listeners_item__routes_item)
                                        if not all(prop in data__listeners_item__routes_item for prop in ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters']):
                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+" must contain ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'] properties", value=data__listeners_item__routes_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['route_path', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}, rule='required')
                                        data__listeners_item__routes_item_keys = set(data__listeners_item__routes_item.keys())
                                        if "route_path" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("route_path")
                                            data__listeners_item__routes_item__routepath = data__listeners_item__routes_item["route_path"]
                                            if not isinstance(data__listeners_item__routes_item__routepath, (str)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].route_path".format(**locals())+" must be string", value=data__listeners_item__routes_item__routepath, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].route_path".format(**locals())+"", definition={'description': 'Prefix path for this route.', 'type': 'string'}, rule='type')
                                        if "has_one_cluster" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_one_cluster")
                                            data__listeners_item__routes_item__hasonecluster = data__listeners_item__routes_item["has_one_cluster"]
                                            if not isinstance(data__listeners_item__routes_item__hasonecluster, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_one_cluster".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasonecluster, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_one_cluster".format(**locals())+"", definition={'description': 'Is there just one cluster?', 'type': 'boolean'}, rule='type')
                                        if "has_many_clusters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_many_clusters")
                                            data__listeners_item__routes_item__hasmanyclusters = data__listeners_item__routes_item["has_many_clusters"]
                                            if not isinstance(data__listeners_item__routes_item__hasmanyclusters, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_many_clusters".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasmanyclusters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_many_clusters".format(**locals())+"", definition={'description': 'Is there more than one cluster?', 'type': 'boolean'}, rule='type')
                                        if "total_cluster_weight" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("total_cluster_weight")
                                            data__listeners_item__routes_item__totalclusterweight = data__listeners_item__routes_item["total_cluster_weight"]
                                            if not isinstance(data__listeners_item__routes_item__totalclusterweight, (int)) and not (isinstance(data__listeners_item__routes_item__totalclusterweight, float) and data__listeners_item__routes_item__totalclusterweight.is_integer()) or isinstance(data__listeners_item__routes_item__totalclusterweight, bool):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].total_cluster_weight".format(**locals())+" must be integer", value=data__listeners_item__routes_item__totalclusterweight, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].total_cluster_weight".format(**locals())+"", definition={'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, rule='type')
                                        if "clusters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("clusters")
                                            data__listeners_item__routes_item__clusters = data__listeners_item__routes_item["clusters"]
                                            if not isinstance(data__listeners_item__routes_item__clusters, (list, tuple)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters".format(**locals())+" must be array", value=data__listeners_item__routes_item__clusters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters".format(**locals())+"", definition={'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}, rule='type')
                                            data__listeners_item__routes_item__clusters_is_list = isinstance(data__listeners_item__routes_item__clusters, (list, tuple))
                                            if data__listeners_item__routes_item__clusters_is_list:
                                                data__listeners_item__routes_item__clusters_len = len(data__listeners_item__routes_item__clusters)
                                                for data__listeners_item__routes_item__clusters_x, data__listeners_item__routes_item__clusters_item in enumerate(data__listeners_item__routes_item__clusters):
                                                    if not isinstance(data__listeners_item__routes_item__clusters_item, (dict)):
                                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item__clusters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}, rule='type')
                                                    data__listeners_item__routes_item__clusters_item_is_dict = isinstance(data__listeners_item__routes_item__clusters_item, dict)
                                                    if data__listeners_item__routes_item__clusters_item_is_dict:
                                                        data__listeners_item__routes_item__clusters_item_len = len(data__listeners_item__routes_item__clusters_item)
                                                        if not all(prop in data__listeners_item__routes_item__clusters_item for prop in ['cluster_name', 'route_weight']):
                                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+" must contain ['cluster_name', 'route_weight'] properties", value=data__listeners_item__routes_item__clusters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}, rule='required')
                                                        data__listeners_item__routes_item__clusters_item_keys = set(data__listeners_item__routes_item__clusters_item.keys())
                                                        if "cluster_name" in data__listeners_item__routes_item__clusters_item_keys:
                                                            data__listeners_item__routes_item__clusters_item_keys.remove("cluster_name")
                                                            data__listeners_item__routes_item__clusters_item__clustername = data__listeners_item__routes_item__clusters_item["cluster_name"]
                                                            if not isinstance(data__listeners_item__routes_item__clusters_item__clustername, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].cluster_name".format(**locals())+" must be string", value=data__listeners_item__routes_item__clusters_item__clustername, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].cluster_name".format(**locals())+"", definition={'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, rule='type')
                                                        if "route_weight" in data__listeners_item__routes_item__clusters_item_keys:
                                                            data__listeners_item__routes_item__clusters_item_keys.remove("route_weight")
                                                            data__listeners_item__routes_item__clusters_item__routeweight = data__listeners_item__routes_item__clusters_item["route_weight"]
                                                            if not isinstance(data__listeners_item__routes_item__clusters_item__routeweight, (int)) and not (isinstance(data__listeners_item__routes_item__clusters_item__routeweight, float) and data__listeners_item__routes_item__clusters_item__routeweight.is_integer()) or isinstance(data__listeners_item__routes_item__clusters_item__routeweight, bool):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].route_weight".format(**locals())+" must be integer", value=data__listeners_item__routes_item__clusters_item__routeweight, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].route_weight".format(**locals())+"", definition={'description': "this cluster's route's relative weight", 'type': 'integer'}, rule='type')
        if "has_clusters" in data_keys:
            data_keys.remove("has_clusters")
            data__hasclusters = data["has_clusters"]
            if not isinstance(data__hasclusters, (bool)):
                raise JsonSchemaException("data.has_clusters must be boolean", value=data__hasclusters, name="data.has_clusters", definition={'description': 'are there 1 or more clusters?', 'type': 'boolean'}, rule='type')
        if "clusters" in data_keys:
            data_keys.remove("clusters")
            data__clusters = data["clusters"]
            if not isinstance(data__clusters, (list, tuple)):
                raise JsonSchemaException("data.clusters must be array", value=data__clusters, name="data.clusters", definition={'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}, rule='type')
            data__clusters_is_list = isinstance(data__clusters, (list, tuple))
            if data__clusters_is_list:
                data__clusters_len = len(data__clusters)
                for data__clusters_x, data__clusters_item in enumerate(data__clusters):
                    if not isinstance(data__clusters_item, (dict)):
                        raise JsonSchemaException(""+"data.clusters[{data__clusters_x}]".format(**locals())+" must be object", value=data__clusters_item, name=""+"data.clusters[{data__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['name', 'uses_http2', 'endpoints'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}, rule='type')
                    data__clusters_item_is_dict = isinstance(data__clusters_item, dict)
                    if data__clusters_item_is_dict:
                        data__clusters_item_len = len(data__clusters_item)
                        if not all(prop in data__clusters_item for prop in ['name', 'uses_http2', 'endpoints']):
                            raise JsonSchemaException(""+"data.clusters[{data__clusters_x}]".format(**locals())+" must contain ['name', 'uses_http2', 'endpoints'] properties", value=data__clusters_item, name=""+"data.clusters[{data__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['name', 'uses_http2', 'endpoints'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}, rule='required')
                        data__clusters_item_keys = set(data__clusters_item.keys())
                        if "name" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("name")
                            data__clusters_item__name = data__clusters_item["name"]
                            if not isinstance(data__clusters_item__name, (str)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].name".format(**locals())+" must be string", value=data__clusters_item__name, name=""+"data.clusters[{data__clusters_x}].name".format(**locals())+"", definition={'description': 'name of the service', 'type': 'string'}, rule='type')
                        if "uses_http2" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("uses_http2")
                            data__clusters_item__useshttp2 = data__clusters_item["uses_http2"]
                            if not isinstance(data__clusters_item__useshttp2, (bool)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].uses_http2".format(**locals())+" must be boolean", value=data__clusters_item__useshttp2, name=""+"data.clusters[{data__clusters_x}].uses_http2".format(**locals())+"", definition={'description': 'uses HTTP2 for connections', 'type': 'boolean'}, rule='type')
                        if "endpoints" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("endpoints")
                            data__clusters_item__endpoints = data__clusters_item["endpoints"]
                            if not isinstance(data__clusters_item__endpoints, (list, tuple)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints".format(**locals())+" must be array", value=data__clusters_item__endpoints, name=""+"data.clusters[{data__clusters_x}].endpoints".format(**locals())+"", definition={'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}, rule='type')
                            data__clusters_item__endpoints_is_list = isinstance(data__clusters_item__endpoints, (list, tuple))
                            if data__clusters_item__endpoints_is_list:
                                data__clusters_item__endpoints_len = len(data__clusters_item__endpoints)
                                for data__clusters_item__endpoints_x, data__clusters_item__endpoints_item in enumerate(data__clusters_item__endpoints):
                                    if not isinstance(data__clusters_item__endpoints_item, (dict)):
                                        raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+" must be object", value=data__clusters_item__endpoints_item, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}, rule='type')
                                    data__clusters_item__endpoints_item_is_dict = isinstance(data__clusters_item__endpoints_item, dict)
                                    if data__clusters_item__endpoints_item_is_dict:
                                        data__clusters_item__endpoints_item_len = len(data__clusters_item__endpoints_item)
                                        if not all(prop in data__clusters_item__endpoints_item for prop in ['ipv4', 'port']):
                                            raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+" must contain ['ipv4', 'port'] properties", value=data__clusters_item__endpoints_item, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['ipv4', 'port'], 'properties': {'ipv4': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}, rule='required')
                                        data__clusters_item__endpoints_item_keys = set(data__clusters_item__endpoints_item.keys())
                                        if "ipv4" in data__clusters_item__endpoints_item_keys:
                                            data__clusters_item__endpoints_item_keys.remove("ipv4")
                                            data__clusters_item__endpoints_item__ipv4 = data__clusters_item__endpoints_item["ipv4"]
                                            if not isinstance(data__clusters_item__endpoints_item__ipv4, (str)):
                                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].ipv4".format(**locals())+" must be string", value=data__clusters_item__endpoints_item__ipv4, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].ipv4".format(**locals())+"", definition={'description': 'IPv4 address of the instance.', 'type': 'string'}, rule='type')
                                        if "port" in data__clusters_item__endpoints_item_keys:
                                            data__clusters_item__endpoints_item_keys.remove("port")
                                            data__clusters_item__endpoints_item__port = data__clusters_item__endpoints_item["port"]
                                            if not isinstance(data__clusters_item__endpoints_item__port, (int)) and not (isinstance(data__clusters_item__endpoints_item__port, float) and data__clusters_item__endpoints_item__port.is_integer()) or isinstance(data__clusters_item__endpoints_item__port, bool):
                                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].port".format(**locals())+" must be integer", value=data__clusters_item__endpoints_item__port, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].port".format(**locals())+"", definition={'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}, rule='type')
    return data