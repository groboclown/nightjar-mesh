# DO NOT MODIFY
# AUTO-GENERATED CODE.

# pylint: ignore

from typing import Dict, Any

VERSION = "2.14.4"
from ..fastjsonschema_replacement import JsonSchemaException


NoneType = type(None)

def validate_proxy_input_schema_yaml(data: Dict[str, Any]) -> Dict[str, Any]:
    if not isinstance(data, (dict)):
        raise JsonSchemaException("data must be object", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Input data for the mustache file generation.  The data is constructed in the script, but this file keeps the template reference easy.', 'type': 'object', 'required': ['schema-version', 'network_name', 'service_member', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'], 'properties': {'schema-version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'network_name': {'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, 'service_member': {'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, 'has_admin_port': {'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, 'admin_port': {'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, 'listeners': {'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, 'has_clusters': {'description': 'are there 1 or more clusters?', 'type': 'boolean'}, 'clusters': {'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'hosts_are_ipv4': {'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, 'hosts_are_ipv6': {'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, 'hosts_are_hostname': {'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}}, '$id': 'file:/tmp/tmp93fil6rp/proxy-input-schema.yaml'}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_len = len(data)
        if not all(prop in data for prop in ['schema-version', 'network_name', 'service_member', 'has_admin_port', 'listeners', 'has_clusters', 'clusters']):
            raise JsonSchemaException("data must contain ['schema-version', 'network_name', 'service_member', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'] properties", value=data, name="data", definition={'$schema': 'https://json-schema.org/draft-07/schema', 'description': 'Input data for the mustache file generation.  The data is constructed in the script, but this file keeps the template reference easy.', 'type': 'object', 'required': ['schema-version', 'network_name', 'service_member', 'has_admin_port', 'listeners', 'has_clusters', 'clusters'], 'properties': {'schema-version': {'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, 'network_name': {'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, 'service_member': {'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, 'has_admin_port': {'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, 'admin_port': {'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, 'listeners': {'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, 'has_clusters': {'description': 'are there 1 or more clusters?', 'type': 'boolean'}, 'clusters': {'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'hosts_are_ipv4': {'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, 'hosts_are_ipv6': {'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, 'hosts_are_hostname': {'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}}, '$id': 'file:/tmp/tmp93fil6rp/proxy-input-schema.yaml'}, rule='required')
        data_keys = set(data.keys())
        if "schema-version" in data_keys:
            data_keys.remove("schema-version")
            data__schemaversion = data["schema-version"]
            if data__schemaversion != "v1":
                raise JsonSchemaException("data.schema-version must be same as const definition", value=data__schemaversion, name="data.schema-version", definition={'description': 'Version of this document\'s schema.  The value must be the string value "v1".', 'const': 'v1'}, rule='const')
        if "network_name" in data_keys:
            data_keys.remove("network_name")
            data__networkname = data["network_name"]
            if not isinstance(data__networkname, (str)):
                raise JsonSchemaException("data.network_name must be string", value=data__networkname, name="data.network_name", definition={'description': 'Name of the network.  Generally, the Cloud Map Network Id.', 'type': 'string'}, rule='type')
        if "service_member" in data_keys:
            data_keys.remove("service_member")
            data__servicemember = data["service_member"]
            if not isinstance(data__servicemember, (str)):
                raise JsonSchemaException("data.service_member must be string", value=data__servicemember, name="data.service_member", definition={'description': 'Name of the service member.  Generally, the service name plus the color.', 'type': 'string'}, rule='type')
        if "has_admin_port" in data_keys:
            data_keys.remove("has_admin_port")
            data__hasadminport = data["has_admin_port"]
            if not isinstance(data__hasadminport, (bool)):
                raise JsonSchemaException("data.has_admin_port must be boolean", value=data__hasadminport, name="data.has_admin_port", definition={'description': 'Set to True if the admin_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.\n', 'type': 'boolean'}, rule='type')
        if "admin_port" in data_keys:
            data_keys.remove("admin_port")
            data__adminport = data["admin_port"]
            if not isinstance(data__adminport, (int, NoneType)) and not (isinstance(data__adminport, float) and data__adminport.is_integer()) or isinstance(data__adminport, bool):
                raise JsonSchemaException("data.admin_port must be integer or null", value=data__adminport, name="data.admin_port", definition={'description': 'Envoy administration listening port.', 'type': ['integer', 'null']}, rule='type')
        if "listeners" in data_keys:
            data_keys.remove("listeners")
            data__listeners = data["listeners"]
            if not isinstance(data__listeners, (list, tuple)):
                raise JsonSchemaException("data.listeners must be array", value=data__listeners, name="data.listeners", definition={'description': 'list of mesh routing definitions', 'type': 'array', 'items': {'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}}, rule='type')
            data__listeners_is_list = isinstance(data__listeners, (list, tuple))
            if data__listeners_is_list:
                data__listeners_len = len(data__listeners)
                for data__listeners_x, data__listeners_item in enumerate(data__listeners):
                    if not isinstance(data__listeners_item, (dict)):
                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}]".format(**locals())+" must be object", value=data__listeners_item, name=""+"data.listeners[{data__listeners_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}, rule='type')
                    data__listeners_item_is_dict = isinstance(data__listeners_item, dict)
                    if data__listeners_item_is_dict:
                        data__listeners_item_len = len(data__listeners_item)
                        if not all(prop in data__listeners_item for prop in ['has_mesh_port', 'routes']):
                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}]".format(**locals())+" must contain ['has_mesh_port', 'routes'] properties", value=data__listeners_item, name=""+"data.listeners[{data__listeners_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['has_mesh_port', 'routes'], 'properties': {'has_mesh_port': {'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, 'mesh_port': {'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, 'routes': {'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}}}, rule='required')
                        data__listeners_item_keys = set(data__listeners_item.keys())
                        if "has_mesh_port" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("has_mesh_port")
                            data__listeners_item__hasmeshport = data__listeners_item["has_mesh_port"]
                            if not isinstance(data__listeners_item__hasmeshport, (bool)):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].has_mesh_port".format(**locals())+" must be boolean", value=data__listeners_item__hasmeshport, name=""+"data.listeners[{data__listeners_x}].has_mesh_port".format(**locals())+"", definition={'description': 'Set to True if the mesh_port value is set.  If not set, then an appropriate placeholder must be used to allow later processing to replace the value.  In the case of no mesh_port, there must be at most one listener with no mesh_port.\n', 'type': 'boolean'}, rule='type')
                        if "mesh_port" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("mesh_port")
                            data__listeners_item__meshport = data__listeners_item["mesh_port"]
                            if not isinstance(data__listeners_item__meshport, (int, NoneType)) and not (isinstance(data__listeners_item__meshport, float) and data__listeners_item__meshport.is_integer()) or isinstance(data__listeners_item__meshport, bool):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].mesh_port".format(**locals())+" must be integer or null", value=data__listeners_item__meshport, name=""+"data.listeners[{data__listeners_x}].mesh_port".format(**locals())+"", definition={'description': 'egress port that the service connects to for sending requests to other members of the mesh.', 'type': ['integer', 'null']}, rule='type')
                        if "routes" in data__listeners_item_keys:
                            data__listeners_item_keys.remove("routes")
                            data__listeners_item__routes = data__listeners_item["routes"]
                            if not isinstance(data__listeners_item__routes, (list, tuple)):
                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes".format(**locals())+" must be array", value=data__listeners_item__routes, name=""+"data.listeners[{data__listeners_x}].routes".format(**locals())+"", definition={'description': 'List of routes and their weights.', 'type': 'array', 'items': {'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}}, rule='type')
                            data__listeners_item__routes_is_list = isinstance(data__listeners_item__routes, (list, tuple))
                            if data__listeners_item__routes_is_list:
                                data__listeners_item__routes_len = len(data__listeners_item__routes)
                                for data__listeners_item__routes_x, data__listeners_item__routes_item in enumerate(data__listeners_item__routes):
                                    if not isinstance(data__listeners_item__routes_item, (dict)):
                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}, rule='type')
                                    data__listeners_item__routes_item_is_dict = isinstance(data__listeners_item__routes_item, dict)
                                    if data__listeners_item__routes_item_is_dict:
                                        data__listeners_item__routes_item_len = len(data__listeners_item__routes_item)
                                        if not all(prop in data__listeners_item__routes_item for prop in ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters']):
                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+" must contain ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'] properties", value=data__listeners_item__routes_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['route_path', 'path_is_prefix', 'path_is_exact', 'path_is_regex', 'path_is_case_sensitive', 'has_header_filters', 'header_filters', 'has_query_filters', 'query_filters', 'has_one_cluster', 'has_many_clusters', 'total_cluster_weight', 'clusters'], 'properties': {'route_path': {'description': 'Prefix path for this route.', 'type': 'string'}, 'path_is_prefix': {'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_exact': {'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_regex': {'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, 'path_is_case_sensitive': {'description': 'the route_path is case sensitive.', 'type': 'boolean'}, 'has_header_filters': {'description': 'Are there any header filters?', 'type': 'boolean'}, 'header_filters': {'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_query_filters': {'description': 'Are there any query parameter filters?', 'type': 'boolean'}, 'query_filters': {'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, 'has_one_cluster': {'description': 'Is there just one cluster?', 'type': 'boolean'}, 'has_many_clusters': {'description': 'Is there more than one cluster?', 'type': 'boolean'}, 'total_cluster_weight': {'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, 'clusters': {'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}}}, rule='required')
                                        data__listeners_item__routes_item_keys = set(data__listeners_item__routes_item.keys())
                                        if "route_path" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("route_path")
                                            data__listeners_item__routes_item__routepath = data__listeners_item__routes_item["route_path"]
                                            if not isinstance(data__listeners_item__routes_item__routepath, (str)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].route_path".format(**locals())+" must be string", value=data__listeners_item__routes_item__routepath, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].route_path".format(**locals())+"", definition={'description': 'Prefix path for this route.', 'type': 'string'}, rule='type')
                                        if "path_is_prefix" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("path_is_prefix")
                                            data__listeners_item__routes_item__pathisprefix = data__listeners_item__routes_item["path_is_prefix"]
                                            if not isinstance(data__listeners_item__routes_item__pathisprefix, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_prefix".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__pathisprefix, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_prefix".format(**locals())+"", definition={'description': 'route_path is a prefix. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, rule='type')
                                        if "path_is_exact" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("path_is_exact")
                                            data__listeners_item__routes_item__pathisexact = data__listeners_item__routes_item["path_is_exact"]
                                            if not isinstance(data__listeners_item__routes_item__pathisexact, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_exact".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__pathisexact, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_exact".format(**locals())+"", definition={'description': 'route_path defines an exact path. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, rule='type')
                                        if "path_is_regex" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("path_is_regex")
                                            data__listeners_item__routes_item__pathisregex = data__listeners_item__routes_item["path_is_regex"]
                                            if not isinstance(data__listeners_item__routes_item__pathisregex, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_regex".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__pathisregex, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_regex".format(**locals())+"", definition={'description': 'route_path defines a regular expression. Exactly one of path_is_prefix, path_is_exact, and path_is_regex must be true.\n', 'type': 'boolean'}, rule='type')
                                        if "path_is_case_sensitive" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("path_is_case_sensitive")
                                            data__listeners_item__routes_item__pathiscasesensitive = data__listeners_item__routes_item["path_is_case_sensitive"]
                                            if not isinstance(data__listeners_item__routes_item__pathiscasesensitive, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_case_sensitive".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__pathiscasesensitive, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].path_is_case_sensitive".format(**locals())+"", definition={'description': 'the route_path is case sensitive.', 'type': 'boolean'}, rule='type')
                                        if "has_header_filters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_header_filters")
                                            data__listeners_item__routes_item__hasheaderfilters = data__listeners_item__routes_item["has_header_filters"]
                                            if not isinstance(data__listeners_item__routes_item__hasheaderfilters, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_header_filters".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasheaderfilters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_header_filters".format(**locals())+"", definition={'description': 'Are there any header filters?', 'type': 'boolean'}, rule='type')
                                        if "header_filters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("header_filters")
                                            data__listeners_item__routes_item__headerfilters = data__listeners_item__routes_item["header_filters"]
                                            if not isinstance(data__listeners_item__routes_item__headerfilters, (list, tuple)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters".format(**locals())+" must be array", value=data__listeners_item__routes_item__headerfilters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters".format(**locals())+"", definition={'description': 'filters traffic to the cluster based on header values.', 'type': 'array', 'items': {'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, rule='type')
                                            data__listeners_item__routes_item__headerfilters_is_list = isinstance(data__listeners_item__routes_item__headerfilters, (list, tuple))
                                            if data__listeners_item__routes_item__headerfilters_is_list:
                                                data__listeners_item__routes_item__headerfilters_len = len(data__listeners_item__routes_item__headerfilters)
                                                for data__listeners_item__routes_item__headerfilters_x, data__listeners_item__routes_item__headerfilters_item in enumerate(data__listeners_item__routes_item__headerfilters):
                                                    if not isinstance(data__listeners_item__routes_item__headerfilters_item, (dict)):
                                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item__headerfilters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}]".format(**locals())+"", definition={'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}, rule='type')
                                                    data__listeners_item__routes_item__headerfilters_item_is_dict = isinstance(data__listeners_item__routes_item__headerfilters_item, dict)
                                                    if data__listeners_item__routes_item__headerfilters_item_is_dict:
                                                        data__listeners_item__routes_item__headerfilters_item_len = len(data__listeners_item__routes_item__headerfilters_item)
                                                        if not all(prop in data__listeners_item__routes_item__headerfilters_item for prop in ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive']):
                                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}]".format(**locals())+" must contain ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'] properties", value=data__listeners_item__routes_item__headerfilters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}]".format(**locals())+"", definition={'description': 'filters traffic to the cluster based on a header value.', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'header name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, 'invert_match': {'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}, rule='required')
                                                        data__listeners_item__routes_item__headerfilters_item_keys = set(data__listeners_item__routes_item__headerfilters_item.keys())
                                                        if "name" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("name")
                                                            data__listeners_item__routes_item__headerfilters_item__name = data__listeners_item__routes_item__headerfilters_item["name"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__name, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].name".format(**locals())+" must be string", value=data__listeners_item__routes_item__headerfilters_item__name, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].name".format(**locals())+"", definition={'description': 'header name in the request.', 'type': 'string'}, rule='type')
                                                        if "match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("match")
                                                            data__listeners_item__routes_item__headerfilters_item__match = data__listeners_item__routes_item__headerfilters_item["match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__match, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].match".format(**locals())+" must be string", value=data__listeners_item__routes_item__headerfilters_item__match, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].match".format(**locals())+"", definition={'description': 'value to match on.', 'type': 'string'}, rule='type')
                                                        if "is_exact_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("is_exact_match")
                                                            data__listeners_item__routes_item__headerfilters_item__isexactmatch = data__listeners_item__routes_item__headerfilters_item["is_exact_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__isexactmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_exact_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__isexactmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_exact_match".format(**locals())+"", definition={'description': 'If specified, header match will be performed based on the value of the header.', 'type': 'boolean'}, rule='type')
                                                        if "is_regex_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("is_regex_match")
                                                            data__listeners_item__routes_item__headerfilters_item__isregexmatch = data__listeners_item__routes_item__headerfilters_item["is_regex_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__isregexmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_regex_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__isregexmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_regex_match".format(**locals())+"", definition={'description': 'If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_present_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("is_present_match")
                                                            data__listeners_item__routes_item__headerfilters_item__ispresentmatch = data__listeners_item__routes_item__headerfilters_item["is_present_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__ispresentmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_present_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__ispresentmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_present_match".format(**locals())+"", definition={'description': 'If specified, header match will be performed based on whether the header is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_suffix_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("is_suffix_match")
                                                            data__listeners_item__routes_item__headerfilters_item__issuffixmatch = data__listeners_item__routes_item__headerfilters_item["is_suffix_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__issuffixmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_suffix_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__issuffixmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_suffix_match".format(**locals())+"", definition={'description': 'If specified, header match will be performed based on the suffix of the header value.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_prefix_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("is_prefix_match")
                                                            data__listeners_item__routes_item__headerfilters_item__isprefixmatch = data__listeners_item__routes_item__headerfilters_item["is_prefix_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__isprefixmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_prefix_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__isprefixmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].is_prefix_match".format(**locals())+"", definition={'description': 'If specified, header match will be performed based on the prefix of the header value.\n', 'type': 'boolean'}, rule='type')
                                                        if "invert_match" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("invert_match")
                                                            data__listeners_item__routes_item__headerfilters_item__invertmatch = data__listeners_item__routes_item__headerfilters_item["invert_match"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__invertmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].invert_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__invertmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].invert_match".format(**locals())+"", definition={'description': 'If true, the match result will be inverted before checking. Defaults to false.', 'type': 'boolean'}, rule='type')
                                                        if "case_sensitive" in data__listeners_item__routes_item__headerfilters_item_keys:
                                                            data__listeners_item__routes_item__headerfilters_item_keys.remove("case_sensitive")
                                                            data__listeners_item__routes_item__headerfilters_item__casesensitive = data__listeners_item__routes_item__headerfilters_item["case_sensitive"]
                                                            if not isinstance(data__listeners_item__routes_item__headerfilters_item__casesensitive, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].case_sensitive".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__headerfilters_item__casesensitive, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].header_filters[{data__listeners_item__routes_item__headerfilters_x}].case_sensitive".format(**locals())+"", definition={'type': 'boolean'}, rule='type')
                                        if "has_query_filters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_query_filters")
                                            data__listeners_item__routes_item__hasqueryfilters = data__listeners_item__routes_item["has_query_filters"]
                                            if not isinstance(data__listeners_item__routes_item__hasqueryfilters, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_query_filters".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasqueryfilters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_query_filters".format(**locals())+"", definition={'description': 'Are there any query parameter filters?', 'type': 'boolean'}, rule='type')
                                        if "query_filters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("query_filters")
                                            data__listeners_item__routes_item__queryfilters = data__listeners_item__routes_item["query_filters"]
                                            if not isinstance(data__listeners_item__routes_item__queryfilters, (list, tuple)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters".format(**locals())+" must be array", value=data__listeners_item__routes_item__queryfilters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters".format(**locals())+"", definition={'description': 'filters traffic to the cluster based on query parameters.', 'type': 'array', 'items': {'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}}, rule='type')
                                            data__listeners_item__routes_item__queryfilters_is_list = isinstance(data__listeners_item__routes_item__queryfilters, (list, tuple))
                                            if data__listeners_item__routes_item__queryfilters_is_list:
                                                data__listeners_item__routes_item__queryfilters_len = len(data__listeners_item__routes_item__queryfilters)
                                                for data__listeners_item__routes_item__queryfilters_x, data__listeners_item__routes_item__queryfilters_item in enumerate(data__listeners_item__routes_item__queryfilters):
                                                    if not isinstance(data__listeners_item__routes_item__queryfilters_item, (dict)):
                                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item__queryfilters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}]".format(**locals())+"", definition={'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}, rule='type')
                                                    data__listeners_item__routes_item__queryfilters_item_is_dict = isinstance(data__listeners_item__routes_item__queryfilters_item, dict)
                                                    if data__listeners_item__routes_item__queryfilters_item_is_dict:
                                                        data__listeners_item__routes_item__queryfilters_item_len = len(data__listeners_item__routes_item__queryfilters_item)
                                                        if not all(prop in data__listeners_item__routes_item__queryfilters_item for prop in ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive']):
                                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}]".format(**locals())+" must contain ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'] properties", value=data__listeners_item__routes_item__queryfilters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}]".format(**locals())+"", definition={'description': 'A query parameter filter', 'type': 'object', 'required': ['name', 'is_exact_match', 'is_regex_match', 'is_present_match', 'is_suffix_match', 'is_prefix_match', 'invert_match', 'case_sensitive'], 'properties': {'name': {'description': 'parameter name in the request.', 'type': 'string'}, 'match': {'description': 'value to match on.', 'type': 'string'}, 'is_exact_match': {'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, 'is_regex_match': {'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, 'is_present_match': {'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, 'is_suffix_match': {'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, 'is_prefix_match': {'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, 'case_sensitive': {'type': 'boolean'}}}, rule='required')
                                                        data__listeners_item__routes_item__queryfilters_item_keys = set(data__listeners_item__routes_item__queryfilters_item.keys())
                                                        if "name" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("name")
                                                            data__listeners_item__routes_item__queryfilters_item__name = data__listeners_item__routes_item__queryfilters_item["name"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__name, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].name".format(**locals())+" must be string", value=data__listeners_item__routes_item__queryfilters_item__name, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].name".format(**locals())+"", definition={'description': 'parameter name in the request.', 'type': 'string'}, rule='type')
                                                        if "match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("match")
                                                            data__listeners_item__routes_item__queryfilters_item__match = data__listeners_item__routes_item__queryfilters_item["match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__match, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].match".format(**locals())+" must be string", value=data__listeners_item__routes_item__queryfilters_item__match, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].match".format(**locals())+"", definition={'description': 'value to match on.', 'type': 'string'}, rule='type')
                                                        if "is_exact_match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("is_exact_match")
                                                            data__listeners_item__routes_item__queryfilters_item__isexactmatch = data__listeners_item__routes_item__queryfilters_item["is_exact_match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__isexactmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_exact_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__isexactmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_exact_match".format(**locals())+"", definition={'description': 'If specified, parameter match will be performed based on the value of the header.', 'type': 'boolean'}, rule='type')
                                                        if "is_regex_match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("is_regex_match")
                                                            data__listeners_item__routes_item__queryfilters_item__isregexmatch = data__listeners_item__routes_item__queryfilters_item["is_regex_match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__isregexmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_regex_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__isregexmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_regex_match".format(**locals())+"", definition={'description': 'If specified, this regex string is a regular expression rule which implies the entire request parameter value must match the regex. The rule will not match if only a subsequence of the request parameter value matches the regex.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_present_match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("is_present_match")
                                                            data__listeners_item__routes_item__queryfilters_item__ispresentmatch = data__listeners_item__routes_item__queryfilters_item["is_present_match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__ispresentmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_present_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__ispresentmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_present_match".format(**locals())+"", definition={'description': 'If specified, parameter match will be performed based on whether the parameter is in the request.  The "match" property will be ignored.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_suffix_match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("is_suffix_match")
                                                            data__listeners_item__routes_item__queryfilters_item__issuffixmatch = data__listeners_item__routes_item__queryfilters_item["is_suffix_match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__issuffixmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_suffix_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__issuffixmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_suffix_match".format(**locals())+"", definition={'description': 'If specified, parameter match will be performed based on the suffix of the parameter value.\n', 'type': 'boolean'}, rule='type')
                                                        if "is_prefix_match" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("is_prefix_match")
                                                            data__listeners_item__routes_item__queryfilters_item__isprefixmatch = data__listeners_item__routes_item__queryfilters_item["is_prefix_match"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__isprefixmatch, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_prefix_match".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__isprefixmatch, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].is_prefix_match".format(**locals())+"", definition={'description': 'If specified, parameter match will be performed based on the prefix of the parameter value.\n', 'type': 'boolean'}, rule='type')
                                                        if "case_sensitive" in data__listeners_item__routes_item__queryfilters_item_keys:
                                                            data__listeners_item__routes_item__queryfilters_item_keys.remove("case_sensitive")
                                                            data__listeners_item__routes_item__queryfilters_item__casesensitive = data__listeners_item__routes_item__queryfilters_item["case_sensitive"]
                                                            if not isinstance(data__listeners_item__routes_item__queryfilters_item__casesensitive, (bool)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].case_sensitive".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__queryfilters_item__casesensitive, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].query_filters[{data__listeners_item__routes_item__queryfilters_x}].case_sensitive".format(**locals())+"", definition={'type': 'boolean'}, rule='type')
                                        if "has_one_cluster" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_one_cluster")
                                            data__listeners_item__routes_item__hasonecluster = data__listeners_item__routes_item["has_one_cluster"]
                                            if not isinstance(data__listeners_item__routes_item__hasonecluster, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_one_cluster".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasonecluster, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_one_cluster".format(**locals())+"", definition={'description': 'Is there just one cluster?', 'type': 'boolean'}, rule='type')
                                        if "has_many_clusters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("has_many_clusters")
                                            data__listeners_item__routes_item__hasmanyclusters = data__listeners_item__routes_item["has_many_clusters"]
                                            if not isinstance(data__listeners_item__routes_item__hasmanyclusters, (bool)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_many_clusters".format(**locals())+" must be boolean", value=data__listeners_item__routes_item__hasmanyclusters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].has_many_clusters".format(**locals())+"", definition={'description': 'Is there more than one cluster?', 'type': 'boolean'}, rule='type')
                                        if "total_cluster_weight" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("total_cluster_weight")
                                            data__listeners_item__routes_item__totalclusterweight = data__listeners_item__routes_item["total_cluster_weight"]
                                            if not isinstance(data__listeners_item__routes_item__totalclusterweight, (int)) and not (isinstance(data__listeners_item__routes_item__totalclusterweight, float) and data__listeners_item__routes_item__totalclusterweight.is_integer()) or isinstance(data__listeners_item__routes_item__totalclusterweight, bool):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].total_cluster_weight".format(**locals())+" must be integer", value=data__listeners_item__routes_item__totalclusterweight, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].total_cluster_weight".format(**locals())+"", definition={'description': "sum of all of route's cluster's weights.", 'type': 'integer'}, rule='type')
                                        if "clusters" in data__listeners_item__routes_item_keys:
                                            data__listeners_item__routes_item_keys.remove("clusters")
                                            data__listeners_item__routes_item__clusters = data__listeners_item__routes_item["clusters"]
                                            if not isinstance(data__listeners_item__routes_item__clusters, (list, tuple)):
                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters".format(**locals())+" must be array", value=data__listeners_item__routes_item__clusters, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters".format(**locals())+"", definition={'description': 'list of clusters that handle this path prefix.', 'type': 'array', 'items': {'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}}, rule='type')
                                            data__listeners_item__routes_item__clusters_is_list = isinstance(data__listeners_item__routes_item__clusters, (list, tuple))
                                            if data__listeners_item__routes_item__clusters_is_list:
                                                data__listeners_item__routes_item__clusters_len = len(data__listeners_item__routes_item__clusters)
                                                for data__listeners_item__routes_item__clusters_x, data__listeners_item__routes_item__clusters_item in enumerate(data__listeners_item__routes_item__clusters):
                                                    if not isinstance(data__listeners_item__routes_item__clusters_item, (dict)):
                                                        raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+" must be object", value=data__listeners_item__routes_item__clusters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}, rule='type')
                                                    data__listeners_item__routes_item__clusters_item_is_dict = isinstance(data__listeners_item__routes_item__clusters_item, dict)
                                                    if data__listeners_item__routes_item__clusters_item_is_dict:
                                                        data__listeners_item__routes_item__clusters_item_len = len(data__listeners_item__routes_item__clusters_item)
                                                        if not all(prop in data__listeners_item__routes_item__clusters_item for prop in ['cluster_name', 'route_weight']):
                                                            raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+" must contain ['cluster_name', 'route_weight'] properties", value=data__listeners_item__routes_item__clusters_item, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['cluster_name', 'route_weight'], 'properties': {'cluster_name': {'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, 'route_weight': {'description': "this cluster's route's relative weight", 'type': 'integer'}}}, rule='required')
                                                        data__listeners_item__routes_item__clusters_item_keys = set(data__listeners_item__routes_item__clusters_item.keys())
                                                        if "cluster_name" in data__listeners_item__routes_item__clusters_item_keys:
                                                            data__listeners_item__routes_item__clusters_item_keys.remove("cluster_name")
                                                            data__listeners_item__routes_item__clusters_item__clustername = data__listeners_item__routes_item__clusters_item["cluster_name"]
                                                            if not isinstance(data__listeners_item__routes_item__clusters_item__clustername, (str)):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].cluster_name".format(**locals())+" must be string", value=data__listeners_item__routes_item__clusters_item__clustername, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].cluster_name".format(**locals())+"", definition={'description': 'name of the cluster, in the cluster section.', 'type': 'string'}, rule='type')
                                                        if "route_weight" in data__listeners_item__routes_item__clusters_item_keys:
                                                            data__listeners_item__routes_item__clusters_item_keys.remove("route_weight")
                                                            data__listeners_item__routes_item__clusters_item__routeweight = data__listeners_item__routes_item__clusters_item["route_weight"]
                                                            if not isinstance(data__listeners_item__routes_item__clusters_item__routeweight, (int)) and not (isinstance(data__listeners_item__routes_item__clusters_item__routeweight, float) and data__listeners_item__routes_item__clusters_item__routeweight.is_integer()) or isinstance(data__listeners_item__routes_item__clusters_item__routeweight, bool):
                                                                raise JsonSchemaException(""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].route_weight".format(**locals())+" must be integer", value=data__listeners_item__routes_item__clusters_item__routeweight, name=""+"data.listeners[{data__listeners_x}].routes[{data__listeners_item__routes_x}].clusters[{data__listeners_item__routes_item__clusters_x}].route_weight".format(**locals())+"", definition={'description': "this cluster's route's relative weight", 'type': 'integer'}, rule='type')
        if "has_clusters" in data_keys:
            data_keys.remove("has_clusters")
            data__hasclusters = data["has_clusters"]
            if not isinstance(data__hasclusters, (bool)):
                raise JsonSchemaException("data.has_clusters must be boolean", value=data__hasclusters, name="data.has_clusters", definition={'description': 'are there 1 or more clusters?', 'type': 'boolean'}, rule='type')
        if "clusters" in data_keys:
            data_keys.remove("clusters")
            data__clusters = data["clusters"]
            if not isinstance(data__clusters, (list, tuple)):
                raise JsonSchemaException("data.clusters must be array", value=data__clusters, name="data.clusters", definition={'description': 'list of each service/cluster routed to by the listeners.', 'type': 'array', 'items': {'type': 'object', 'required': ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'hosts_are_ipv4': {'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, 'hosts_are_ipv6': {'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, 'hosts_are_hostname': {'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}}, rule='type')
            data__clusters_is_list = isinstance(data__clusters, (list, tuple))
            if data__clusters_is_list:
                data__clusters_len = len(data__clusters)
                for data__clusters_x, data__clusters_item in enumerate(data__clusters):
                    if not isinstance(data__clusters_item, (dict)):
                        raise JsonSchemaException(""+"data.clusters[{data__clusters_x}]".format(**locals())+" must be object", value=data__clusters_item, name=""+"data.clusters[{data__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'hosts_are_ipv4': {'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, 'hosts_are_ipv6': {'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, 'hosts_are_hostname': {'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}, rule='type')
                    data__clusters_item_is_dict = isinstance(data__clusters_item, dict)
                    if data__clusters_item_is_dict:
                        data__clusters_item_len = len(data__clusters_item)
                        if not all(prop in data__clusters_item for prop in ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname']):
                            raise JsonSchemaException(""+"data.clusters[{data__clusters_x}]".format(**locals())+" must contain ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'] properties", value=data__clusters_item, name=""+"data.clusters[{data__clusters_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['name', 'uses_http2', 'endpoints', 'hosts_are_ipv4', 'hosts_are_ipv6', 'hosts_are_hostname'], 'properties': {'name': {'description': 'name of the service', 'type': 'string'}, 'uses_http2': {'description': 'uses HTTP2 for connections', 'type': 'boolean'}, 'hosts_are_ipv4': {'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, 'hosts_are_ipv6': {'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, 'hosts_are_hostname': {'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, 'endpoints': {'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}}}, rule='required')
                        data__clusters_item_keys = set(data__clusters_item.keys())
                        if "name" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("name")
                            data__clusters_item__name = data__clusters_item["name"]
                            if not isinstance(data__clusters_item__name, (str)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].name".format(**locals())+" must be string", value=data__clusters_item__name, name=""+"data.clusters[{data__clusters_x}].name".format(**locals())+"", definition={'description': 'name of the service', 'type': 'string'}, rule='type')
                        if "uses_http2" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("uses_http2")
                            data__clusters_item__useshttp2 = data__clusters_item["uses_http2"]
                            if not isinstance(data__clusters_item__useshttp2, (bool)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].uses_http2".format(**locals())+" must be boolean", value=data__clusters_item__useshttp2, name=""+"data.clusters[{data__clusters_x}].uses_http2".format(**locals())+"", definition={'description': 'uses HTTP2 for connections', 'type': 'boolean'}, rule='type')
                        if "hosts_are_ipv4" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("hosts_are_ipv4")
                            data__clusters_item__hostsareipv4 = data__clusters_item["hosts_are_ipv4"]
                            if not isinstance(data__clusters_item__hostsareipv4, (bool)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].hosts_are_ipv4".format(**locals())+" must be boolean", value=data__clusters_item__hostsareipv4, name=""+"data.clusters[{data__clusters_x}].hosts_are_ipv4".format(**locals())+"", definition={'description': 'All endpoint host values are ipv4.', 'type': 'boolean'}, rule='type')
                        if "hosts_are_ipv6" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("hosts_are_ipv6")
                            data__clusters_item__hostsareipv6 = data__clusters_item["hosts_are_ipv6"]
                            if not isinstance(data__clusters_item__hostsareipv6, (bool)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].hosts_are_ipv6".format(**locals())+" must be boolean", value=data__clusters_item__hostsareipv6, name=""+"data.clusters[{data__clusters_x}].hosts_are_ipv6".format(**locals())+"", definition={'description': 'All endpoint host values are ipv6', 'type': 'boolean'}, rule='type')
                        if "hosts_are_hostname" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("hosts_are_hostname")
                            data__clusters_item__hostsarehostname = data__clusters_item["hosts_are_hostname"]
                            if not isinstance(data__clusters_item__hostsarehostname, (bool)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].hosts_are_hostname".format(**locals())+" must be boolean", value=data__clusters_item__hostsarehostname, name=""+"data.clusters[{data__clusters_x}].hosts_are_hostname".format(**locals())+"", definition={'description': 'All endpoint host values are hostnames', 'type': 'boolean'}, rule='type')
                        if "endpoints" in data__clusters_item_keys:
                            data__clusters_item_keys.remove("endpoints")
                            data__clusters_item__endpoints = data__clusters_item["endpoints"]
                            if not isinstance(data__clusters_item__endpoints, (list, tuple)):
                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints".format(**locals())+" must be array", value=data__clusters_item__endpoints, name=""+"data.clusters[{data__clusters_x}].endpoints".format(**locals())+"", definition={'description': 'list of connection endpoints', 'type': 'array', 'items': {'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}}, rule='type')
                            data__clusters_item__endpoints_is_list = isinstance(data__clusters_item__endpoints, (list, tuple))
                            if data__clusters_item__endpoints_is_list:
                                data__clusters_item__endpoints_len = len(data__clusters_item__endpoints)
                                for data__clusters_item__endpoints_x, data__clusters_item__endpoints_item in enumerate(data__clusters_item__endpoints):
                                    if not isinstance(data__clusters_item__endpoints_item, (dict)):
                                        raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+" must be object", value=data__clusters_item__endpoints_item, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}, rule='type')
                                    data__clusters_item__endpoints_item_is_dict = isinstance(data__clusters_item__endpoints_item, dict)
                                    if data__clusters_item__endpoints_item_is_dict:
                                        data__clusters_item__endpoints_item_len = len(data__clusters_item__endpoints_item)
                                        if not all(prop in data__clusters_item__endpoints_item for prop in ['host', 'port']):
                                            raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+" must contain ['host', 'port'] properties", value=data__clusters_item__endpoints_item, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}]".format(**locals())+"", definition={'type': 'object', 'required': ['host', 'port'], 'properties': {'host': {'description': 'IPv4 address of the instance.', 'type': 'string'}, 'port': {'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}}}, rule='required')
                                        data__clusters_item__endpoints_item_keys = set(data__clusters_item__endpoints_item.keys())
                                        if "host" in data__clusters_item__endpoints_item_keys:
                                            data__clusters_item__endpoints_item_keys.remove("host")
                                            data__clusters_item__endpoints_item__host = data__clusters_item__endpoints_item["host"]
                                            if not isinstance(data__clusters_item__endpoints_item__host, (str)):
                                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].host".format(**locals())+" must be string", value=data__clusters_item__endpoints_item__host, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].host".format(**locals())+"", definition={'description': 'IPv4 address of the instance.', 'type': 'string'}, rule='type')
                                        if "port" in data__clusters_item__endpoints_item_keys:
                                            data__clusters_item__endpoints_item_keys.remove("port")
                                            data__clusters_item__endpoints_item__port = data__clusters_item__endpoints_item["port"]
                                            if not isinstance(data__clusters_item__endpoints_item__port, (int)) and not (isinstance(data__clusters_item__endpoints_item__port, float) and data__clusters_item__endpoints_item__port.is_integer()) or isinstance(data__clusters_item__endpoints_item__port, bool):
                                                raise JsonSchemaException(""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].port".format(**locals())+" must be integer", value=data__clusters_item__endpoints_item__port, name=""+"data.clusters[{data__clusters_x}].endpoints[{data__clusters_item__endpoints_x}].port".format(**locals())+"", definition={'description': "endpoint listening port.  This is container's host port.", 'type': 'integer'}, rule='type')
    return data